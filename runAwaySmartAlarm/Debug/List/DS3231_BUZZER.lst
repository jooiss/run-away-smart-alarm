###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       22/Dec/2023  06:54:46
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\user\Documents\Term_project\user\DS3231_BUZZER.c
#    Command line =  
#        -f C:\Users\user\AppData\Local\Temp\EWCC0.tmp
#        (C:\Users\user\Documents\Term_project\user\DS3231_BUZZER.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\user\Documents\Term_project\Debug\List -o
#        C:\Users\user\Documents\Term_project\Debug\Obj --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\user\Documents\Term_project\Libraries\CMSIS\DeviceSupport\ -I
#        C:\Users\user\Documents\Term_project\Libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\user\Documents\Term_project\Libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\user\Documents\Term_project\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\user\Documents\Term_project\user\inc\ -I
#        C:\Users\user\Documents\Term_project\user\ -I
#        C:\Users\user\Documents\Term_project\Libraries\LCD\ -Ol -I "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\user\Documents\Term_project\Debug\List\DS3231_BUZZER.lst
#    Object file  =  
#        C:\Users\user\Documents\Term_project\Debug\Obj\DS3231_BUZZER.o
#
###############################################################################

C:\Users\user\Documents\Term_project\user\DS3231_BUZZER.c
      1          #include <DS3231_BUZZER.h>
      2          

   \                                 In section .data, align 4
      3          int Alarm_flag = 1;
   \                     Alarm_flag:
   \   00000000   0x00000001         DC32 1

   \                                 In section .bss, align 4
      4          int Alarm_ONOFF = 0;
   \                     Alarm_ONOFF:
   \   00000000                      DS8 4
      5          
      6          
      7          // @@ @@ @@
      8          /* USER CODE BEGIN PFP */

   \                                 In section .text, align 2, keep-with-next
      9          int decTobcd(uint8_t dec)
     10          {
   \                     decTobcd: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     11          	return ((dec/10)*16)+(dec%10);
   \   00000002   0x000A             MOVS     R2,R1
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x200A             MOVS     R0,#+10
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x230A             MOVS     R3,#+10
   \   0000000C   0xFB91 0xF1F3      SDIV     R1,R1,R3
   \   00000010   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   00000014   0xFB92 0xF2F0      SDIV     R2,R2,R0
   \   00000018   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   0000001C   0x4770             BX       LR               ;; return
     12          }

   \                                 In section .text, align 2, keep-with-next
     13          int bcdTodec(uint8_t bcd)
     14          {
   \                     bcdTodec: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     15          	return (bcd/16*10)+(bcd%16);
   \   00000002   0x000A             MOVS     R2,R1
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x2010             MOVS     R0,#+16
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2310             MOVS     R3,#+16
   \   0000000C   0xFB91 0xF1F3      SDIV     R1,R1,R3
   \   00000010   0x230A             MOVS     R3,#+10
   \   00000012   0xFB03 0x2101      MLA      R1,R3,R1,R2
   \   00000016   0xFB92 0xF2F0      SDIV     R2,R2,R0
   \   0000001A   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   0000001E   0x4770             BX       LR               ;; return
     16          }
     17          

   \                                 In section .text, align 2, keep-with-next
     18          void I2C_Configure(void)
     19            {
   \                     I2C_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     20                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     21                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     22                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000018   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     23                  
     24                  GPIO_InitTypeDef GPIO_InitStructure;
                                          ^
Warning[Pe177]: variable "GPIO_InitStructure" was declared but never referenced
     25                  
     26                  AFIO->MAPR = 0x00000002;
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x40010004
   \   00000022   0x6008             STR      R0,[R1, #+0]
     27                  GPIOB->CRH |= 0x000000FF;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable10_1  ;; 0x40010c04
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x00FF      ORRS     R0,R0,#0xFF
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0x40010c04
   \   00000032   0x6008             STR      R0,[R1, #+0]
     28                  
     29                  I2C_DeInit(I2C1);
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x40005400
   \   00000038   0x.... 0x....      BL       I2C_DeInit
     30                  
     31                  I2C1->CR1 = 0x0000;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x40005400
   \   00000042   0x8008             STRH     R0,[R1, #+0]
     32                  I2C1->CR2 = 0x0008;
   \   00000044   0x2008             MOVS     R0,#+8
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable10_3  ;; 0x40005404
   \   0000004A   0x8008             STRH     R0,[R1, #+0]
     33                  I2C1->CCR = 40;
   \   0000004C   0x2028             MOVS     R0,#+40
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable10_4  ;; 0x4000541c
   \   00000052   0x8008             STRH     R0,[R1, #+0]
     34                  I2C1->TRISE = 0x0009;
   \   00000054   0x2009             MOVS     R0,#+9
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable10_5  ;; 0x40005420
   \   0000005A   0x8008             STRH     R0,[R1, #+0]
     35                  
     36                  I2C_Cmd(I2C1, DISABLE);
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x40005400
   \   00000062   0x.... 0x....      BL       I2C_Cmd
     37                  I2C_Cmd(I2C1, ENABLE);
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x40005400
   \   0000006C   0x.... 0x....      BL       I2C_Cmd
     38          }
   \   00000070   0xBD01             POP      {R0,PC}          ;; return
     39          

   \                                 In section .text, align 2, keep-with-next
     40          uint8_t HW_I2C_Read(I2C_TypeDef* I2Cx, uint8_t DeviceAddr, uint8_t RegisterAddr, uint16_t NumByteToRead, uint8_t* pBuffer)
     41          {
   \                     HW_I2C_Read: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
     42            __IO uint32_t UTIL_Timeout = LONG_TIMEOUT;
   \   0000000A   0xF44F 0x4020      MOV      R0,#+40960
   \   0000000E   0x9000             STR      R0,[SP, #+0]
     43            __IO uint32_t temp;
     44          
     45            (void)(temp);
   \   00000010   0x9800             LDR      R0,[SP, #+0]
   \   00000012   0xE019             B.N      ??HW_I2C_Read_0
     46          
     47          restart:
     48          
     49            UTIL_Timeout = LONG_TIMEOUT;
     50          /* Send START condition */
     51            I2C_GenerateSTART(I2Cx, ENABLE);
     52            /* Test on EV5 and clear it */
     53            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
     54            {
     55              if (UTIL_Timeout-- == 0)
     56                return ERROR;
     57            }
     58          
     59            UTIL_Timeout = LONG_TIMEOUT;
   \                     ??HW_I2C_Read_1: (+1)
   \   00000014   0xF44F 0x4020      MOV      R0,#+40960
   \   00000018   0x9000             STR      R0,[SP, #+0]
     60            /* Send slave address for read */
     61            I2C_Send7bitAddress(I2Cx, DeviceAddr, I2C_Direction_Transmitter);
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       I2C_Send7bitAddress
     62          
     63            while (!I2C_CheckEvent(I2Cx,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??HW_I2C_Read_2: (+1)
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable10_6  ;; 0x70082
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       I2C_CheckEvent
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD11E             BNE.N    ??HW_I2C_Read_3
     64            {
     65              if (UTIL_Timeout-- == 0)
   \                     ??HW_I2C_Read_4: (+1)
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0x1E41             SUBS     R1,R0,#+1
   \   00000038   0x9100             STR      R1,[SP, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD1F3             BNE.N    ??HW_I2C_Read_2
     66              {
     67                I2C_ClearFlag(I2Cx,I2C_FLAG_BUSY|I2C_FLAG_AF);
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable10_7  ;; 0x10020400
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       I2C_ClearFlag
     68                goto restart;
     69              }
     70            }
   \                     ??HW_I2C_Read_0: (+1)
   \   00000048   0xF44F 0x4020      MOV      R0,#+40960
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       I2C_GenerateSTART
   \                     ??HW_I2C_Read_5: (+1)
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable10_8  ;; 0x30001
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       I2C_CheckEvent
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD1D7             BNE.N    ??HW_I2C_Read_1
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0x1E41             SUBS     R1,R0,#+1
   \   00000068   0x9100             STR      R1,[SP, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD1F3             BNE.N    ??HW_I2C_Read_5
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE11B             B.N      ??HW_I2C_Read_6
     71            /* Clear EV6 by setting again the PE bit */
     72            I2C_Cmd(I2Cx, ENABLE);
   \                     ??HW_I2C_Read_3: (+1)
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       I2C_Cmd
     73          
     74            I2C_SendData(I2Cx, RegisterAddr);
   \   0000007A   0x0031             MOVS     R1,R6
   \   0000007C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       I2C_SendData
     75          
     76            /* Test on EV8 and clear it */
     77            UTIL_Timeout = LONG_TIMEOUT;
   \   00000084   0xF44F 0x4020      MOV      R0,#+40960
   \   00000088   0x9000             STR      R0,[SP, #+0]
     78            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??HW_I2C_Read_7: (+1)
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable10_9  ;; 0x70084
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       I2C_CheckEvent
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD106             BNE.N    ??HW_I2C_Read_8
     79            {
     80              if (UTIL_Timeout-- == 0)
   \   00000098   0x9800             LDR      R0,[SP, #+0]
   \   0000009A   0x1E41             SUBS     R1,R0,#+1
   \   0000009C   0x9100             STR      R1,[SP, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD1F3             BNE.N    ??HW_I2C_Read_7
     81               return ERROR;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xE101             B.N      ??HW_I2C_Read_6
     82            }
   \                     ??HW_I2C_Read_8: (+1)
   \   000000A6   0x9E06             LDR      R6,[SP, #+24]
     83          
     84            if (NumByteToRead == 0x01)
   \   000000A8   0x0038             MOVS     R0,R7
   \   000000AA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD00F             BEQ.N    ??HW_I2C_Read_9
     85            {
     86              restart3:
     87              /* Send START condition */
     88              I2C_GenerateSTART(I2Cx, ENABLE);
     89              while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT));
     90              /* Send Slave address for read */
     91              I2C_Send7bitAddress(I2Cx, DeviceAddr, I2C_Direction_Receiver);
     92              /* Wait until ADDR is set */
     93              UTIL_Timeout = LONG_TIMEOUT;
     94              while (!I2C_GetFlagStatus(I2Cx, I2C_FLAG_ADDR))
     95              {
     96                if (UTIL_Timeout-- == 0)
     97                {
     98                  I2C_ClearFlag(I2Cx,I2C_FLAG_BUSY|I2C_FLAG_AF);
     99                  goto restart3;
    100                }
    101              }
    102              /* Clear ACK */
    103              I2C_AcknowledgeConfig(I2Cx, DISABLE);
    104              __disable_irq();
    105              /* Clear ADDR flag */
    106              temp = I2Cx->SR2;
    107              /* Program the STOP */
    108              I2C_GenerateSTOP(I2Cx, ENABLE);
    109              __enable_irq();
    110              while ((I2C_GetLastEvent(I2Cx) & 0x0040) != 0x000040); /* Poll on RxNE */
    111              /* Read the data */
    112              *pBuffer = I2C_ReceiveData(I2Cx);
    113              /* Make sure that the STOP bit is cleared by Hardware before CR1 write access */
    114              while ((I2Cx->CR1&0x200) == 0x200);
    115              /* Enable Acknowledgement to be ready for another reception */
    116              I2C_AcknowledgeConfig(I2Cx, ENABLE);
    117          
    118              return SUCCESS;
    119            }
    120            else
    121              if(NumByteToRead == 0x02)
   \   000000B0   0x0038             MOVS     R0,R7
   \   000000B2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B4   0x2802             CMP      R0,#+2
   \   000000B6   0xF040 0x80A3      BNE.W    ??HW_I2C_Read_10
   \   000000BA   0xE04C             B.N      ??HW_I2C_Read_11
   \                     ??HW_I2C_Read_12: (+1)
   \   000000BC   0x9800             LDR      R0,[SP, #+0]
   \   000000BE   0x1E41             SUBS     R1,R0,#+1
   \   000000C0   0x9100             STR      R1,[SP, #+0]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD118             BNE.N    ??HW_I2C_Read_13
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable10_7  ;; 0x10020400
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       I2C_ClearFlag
   \                     ??HW_I2C_Read_9: (+1)
   \   000000D0   0x2101             MOVS     R1,#+1
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       I2C_GenerateSTART
   \                     ??HW_I2C_Read_14: (+1)
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable10_8  ;; 0x30001
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0x.... 0x....      BL       I2C_CheckEvent
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD0F8             BEQ.N    ??HW_I2C_Read_14
   \   000000E6   0x2201             MOVS     R2,#+1
   \   000000E8   0x0029             MOVS     R1,R5
   \   000000EA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       I2C_Send7bitAddress
   \   000000F2   0xF44F 0x4020      MOV      R0,#+40960
   \   000000F6   0x9000             STR      R0,[SP, #+0]
   \                     ??HW_I2C_Read_13: (+1)
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable10_10  ;; 0x10000002
   \   000000FC   0x0020             MOVS     R0,R4
   \   000000FE   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD0DA             BEQ.N    ??HW_I2C_Read_12
   \   00000106   0x2100             MOVS     R1,#+0
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0x.... 0x....      BL       I2C_AcknowledgeConfig
   \   0000010E   0xB672             CPSID    I
   \   00000110   0x8B20             LDRH     R0,[R4, #+24]
   \   00000112   0x9000             STR      R0,[SP, #+0]
   \   00000114   0x2101             MOVS     R1,#+1
   \   00000116   0x0020             MOVS     R0,R4
   \   00000118   0x.... 0x....      BL       I2C_GenerateSTOP
   \   0000011C   0xB662             CPSIE    I
   \                     ??HW_I2C_Read_15: (+1)
   \   0000011E   0x0020             MOVS     R0,R4
   \   00000120   0x.... 0x....      BL       I2C_GetLastEvent
   \   00000124   0x0640             LSLS     R0,R0,#+25
   \   00000126   0xD5FA             BPL.N    ??HW_I2C_Read_15
   \   00000128   0x0020             MOVS     R0,R4
   \   0000012A   0x.... 0x....      BL       I2C_ReceiveData
   \   0000012E   0x7030             STRB     R0,[R6, #+0]
   \                     ??HW_I2C_Read_16: (+1)
   \   00000130   0x8820             LDRH     R0,[R4, #+0]
   \   00000132   0x0580             LSLS     R0,R0,#+22
   \   00000134   0xD4FC             BMI.N    ??HW_I2C_Read_16
   \   00000136   0x2101             MOVS     R1,#+1
   \   00000138   0x0020             MOVS     R0,R4
   \   0000013A   0x.... 0x....      BL       I2C_AcknowledgeConfig
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0xE0B3             B.N      ??HW_I2C_Read_6
    122              {
    123                restart4:
    124                /* Send START condition */
    125                I2C_GenerateSTART(I2Cx, ENABLE);
    126                while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT));
    127                /* Send EEPROM address for read */
    128                I2C_Send7bitAddress(I2Cx, DeviceAddr, I2C_Direction_Receiver);
    129                I2Cx->CR1 = 0xC01; /* ACK=1; POS =1 */
    130                UTIL_Timeout = LONG_TIMEOUT;
    131                while (!I2C_GetFlagStatus(I2Cx, I2C_FLAG_ADDR))
    132                {
    133                  if (UTIL_Timeout-- == 0)
   \                     ??HW_I2C_Read_17: (+1)
   \   00000142   0x9800             LDR      R0,[SP, #+0]
   \   00000144   0x1E41             SUBS     R1,R0,#+1
   \   00000146   0x9100             STR      R1,[SP, #+0]
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD11B             BNE.N    ??HW_I2C_Read_18
    134                  {
    135                    I2C_ClearFlag(I2Cx,I2C_FLAG_BUSY|I2C_FLAG_AF);
   \   0000014C   0x.... 0x....      LDR.W    R1,??DataTable10_7  ;; 0x10020400
   \   00000150   0x0020             MOVS     R0,R4
   \   00000152   0x.... 0x....      BL       I2C_ClearFlag
    136                    goto restart4;
    137                  }
    138                }
   \                     ??HW_I2C_Read_11: (+1)
   \   00000156   0x2101             MOVS     R1,#+1
   \   00000158   0x0020             MOVS     R0,R4
   \   0000015A   0x.... 0x....      BL       I2C_GenerateSTART
   \                     ??HW_I2C_Read_19: (+1)
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable10_8  ;; 0x30001
   \   00000162   0x0020             MOVS     R0,R4
   \   00000164   0x.... 0x....      BL       I2C_CheckEvent
   \   00000168   0x2800             CMP      R0,#+0
   \   0000016A   0xD0F8             BEQ.N    ??HW_I2C_Read_19
   \   0000016C   0x2201             MOVS     R2,#+1
   \   0000016E   0x0029             MOVS     R1,R5
   \   00000170   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000172   0x0020             MOVS     R0,R4
   \   00000174   0x.... 0x....      BL       I2C_Send7bitAddress
   \   00000178   0xF640 0x4001      MOVW     R0,#+3073
   \   0000017C   0x8020             STRH     R0,[R4, #+0]
   \   0000017E   0xF44F 0x4020      MOV      R0,#+40960
   \   00000182   0x9000             STR      R0,[SP, #+0]
   \                     ??HW_I2C_Read_18: (+1)
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable10_10  ;; 0x10000002
   \   00000188   0x0020             MOVS     R0,R4
   \   0000018A   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000018E   0x2800             CMP      R0,#+0
   \   00000190   0xD0D7             BEQ.N    ??HW_I2C_Read_17
    139                __disable_irq();
   \   00000192   0xB672             CPSID    I
    140                /* Clear ADDR */
    141                temp = I2Cx->SR2;
   \   00000194   0x8B20             LDRH     R0,[R4, #+24]
   \   00000196   0x9000             STR      R0,[SP, #+0]
    142                /* Disable ACK */
    143                I2C_AcknowledgeConfig(I2Cx, DISABLE);
   \   00000198   0x2100             MOVS     R1,#+0
   \   0000019A   0x0020             MOVS     R0,R4
   \   0000019C   0x.... 0x....      BL       I2C_AcknowledgeConfig
    144                __enable_irq();
   \   000001A0   0xB662             CPSIE    I
    145                while ((I2C_GetLastEvent(I2Cx) & 0x0004) != 0x00004); /* Poll on BTF */
   \                     ??HW_I2C_Read_20: (+1)
   \   000001A2   0x0020             MOVS     R0,R4
   \   000001A4   0x.... 0x....      BL       I2C_GetLastEvent
   \   000001A8   0x0740             LSLS     R0,R0,#+29
   \   000001AA   0xD5FA             BPL.N    ??HW_I2C_Read_20
    146          
    147                 __disable_irq();
   \   000001AC   0xB672             CPSID    I
    148                /* Program the STOP */
    149                I2C_GenerateSTOP(I2Cx, ENABLE);
   \   000001AE   0x2101             MOVS     R1,#+1
   \   000001B0   0x0020             MOVS     R0,R4
   \   000001B2   0x.... 0x....      BL       I2C_GenerateSTOP
    150                /* Read first data */
    151                *pBuffer = I2Cx->DR;
   \   000001B6   0x8A20             LDRH     R0,[R4, #+16]
   \   000001B8   0x7030             STRB     R0,[R6, #+0]
    152                pBuffer++;
   \   000001BA   0x1C70             ADDS     R0,R6,#+1
    153                /* Read second data */
    154                *pBuffer = I2Cx->DR;
   \   000001BC   0x8A21             LDRH     R1,[R4, #+16]
   \   000001BE   0x7001             STRB     R1,[R0, #+0]
    155                __enable_irq();
   \   000001C0   0xB662             CPSIE    I
    156                I2Cx->CR1 = 0x0401; /* POS = 0, ACK = 1, PE = 1 */
   \   000001C2   0xF240 0x4001      MOVW     R0,#+1025
   \   000001C6   0x8020             STRH     R0,[R4, #+0]
    157          
    158                return SUCCESS;
   \   000001C8   0x2001             MOVS     R0,#+1
   \   000001CA   0xE06E             B.N      ??HW_I2C_Read_6
    159              }
    160            else
    161            {
    162          restart2:
    163              UTIL_Timeout = LONG_TIMEOUT;
    164              /* Send START condition */
    165              I2C_GenerateSTART(I2Cx, ENABLE);
    166              /* Test on EV5 and clear it */
    167              while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
    168              {
    169                if (UTIL_Timeout-- == 0) return ERROR;
    170              }
    171              UTIL_Timeout = LONG_TIMEOUT;
   \                     ??HW_I2C_Read_21: (+1)
   \   000001CC   0xF44F 0x4020      MOV      R0,#+40960
   \   000001D0   0x9000             STR      R0,[SP, #+0]
    172              /* Send slave address for read */
    173              I2C_Send7bitAddress(I2Cx,  DeviceAddr, I2C_Direction_Receiver);
   \   000001D2   0x2201             MOVS     R2,#+1
   \   000001D4   0x0029             MOVS     R1,R5
   \   000001D6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001D8   0x0020             MOVS     R0,R4
   \   000001DA   0x.... 0x....      BL       I2C_Send7bitAddress
    174              while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
   \                     ??HW_I2C_Read_22: (+1)
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable10_11  ;; 0x30002
   \   000001E2   0x0020             MOVS     R0,R4
   \   000001E4   0x.... 0x....      BL       I2C_CheckEvent
   \   000001E8   0x2800             CMP      R0,#+0
   \   000001EA   0xD152             BNE.N    ??HW_I2C_Read_23
    175              {
    176          
    177                if (UTIL_Timeout-- == 0)
   \                     ??HW_I2C_Read_24: (+1)
   \   000001EC   0x9800             LDR      R0,[SP, #+0]
   \   000001EE   0x1E41             SUBS     R1,R0,#+1
   \   000001F0   0x9100             STR      R1,[SP, #+0]
   \   000001F2   0x2800             CMP      R0,#+0
   \   000001F4   0xD1F3             BNE.N    ??HW_I2C_Read_22
    178                {
    179                  I2C_ClearFlag(I2Cx,I2C_FLAG_BUSY|I2C_FLAG_AF);
   \   000001F6   0x.... 0x....      LDR.W    R1,??DataTable10_7  ;; 0x10020400
   \   000001FA   0x0020             MOVS     R0,R4
   \   000001FC   0x.... 0x....      BL       I2C_ClearFlag
    180                  goto restart2;
    181                }
    182              }
   \                     ??HW_I2C_Read_10: (+1)
   \   00000200   0xF44F 0x4020      MOV      R0,#+40960
   \   00000204   0x9000             STR      R0,[SP, #+0]
   \   00000206   0x2101             MOVS     R1,#+1
   \   00000208   0x0020             MOVS     R0,R4
   \   0000020A   0x.... 0x....      BL       I2C_GenerateSTART
   \                     ??HW_I2C_Read_25: (+1)
   \   0000020E   0x.... 0x....      LDR.W    R1,??DataTable10_8  ;; 0x30001
   \   00000212   0x0020             MOVS     R0,R4
   \   00000214   0x.... 0x....      BL       I2C_CheckEvent
   \   00000218   0x2800             CMP      R0,#+0
   \   0000021A   0xD1D7             BNE.N    ??HW_I2C_Read_21
   \   0000021C   0x9800             LDR      R0,[SP, #+0]
   \   0000021E   0x1E41             SUBS     R1,R0,#+1
   \   00000220   0x9100             STR      R1,[SP, #+0]
   \   00000222   0x2800             CMP      R0,#+0
   \   00000224   0xD1F3             BNE.N    ??HW_I2C_Read_25
   \   00000226   0x2000             MOVS     R0,#+0
   \   00000228   0xE03F             B.N      ??HW_I2C_Read_6
    183          
    184              /* While there is data to be read; here the safe procedure is implemented */
    185              while (NumByteToRead)
    186              {
    187          
    188                if (NumByteToRead != 3) /* Receive bytes from first byte until byte N-3 */
   \                     ??HW_I2C_Read_26: (+1)
   \   0000022A   0x0038             MOVS     R0,R7
   \   0000022C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000022E   0x2803             CMP      R0,#+3
   \   00000230   0xD00A             BEQ.N    ??HW_I2C_Read_27
    189                {
    190                  while ((I2C_GetLastEvent(I2Cx) & 0x00004) != 0x000004); /* Poll on BTF */
   \                     ??HW_I2C_Read_28: (+1)
   \   00000232   0x0020             MOVS     R0,R4
   \   00000234   0x.... 0x....      BL       I2C_GetLastEvent
   \   00000238   0x0740             LSLS     R0,R0,#+29
   \   0000023A   0xD5FA             BPL.N    ??HW_I2C_Read_28
    191                  /* Read data */
    192                  *pBuffer = I2C_ReceiveData(I2Cx);
   \   0000023C   0x0020             MOVS     R0,R4
   \   0000023E   0x.... 0x....      BL       I2C_ReceiveData
   \   00000242   0x7030             STRB     R0,[R6, #+0]
    193                  pBuffer++;
   \   00000244   0x1C76             ADDS     R6,R6,#+1
    194                  /* Decrement the read bytes counter */
    195                  NumByteToRead--;
   \   00000246   0x1E7F             SUBS     R7,R7,#+1
    196                }
    197          
    198                if (NumByteToRead == 3)  /* it remains to read three data: data N-2, data N-1, Data N */
   \                     ??HW_I2C_Read_27: (+1)
   \   00000248   0x0038             MOVS     R0,R7
   \   0000024A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000024C   0x2803             CMP      R0,#+3
   \   0000024E   0xD120             BNE.N    ??HW_I2C_Read_23
    199                {
    200          
    201                  /* Data N-2 in DR and data N -1 in shift register */
    202                  while ((I2C_GetLastEvent(I2Cx) & 0x000004) != 0x0000004); /* Poll on BTF */
   \                     ??HW_I2C_Read_29: (+1)
   \   00000250   0x0020             MOVS     R0,R4
   \   00000252   0x.... 0x....      BL       I2C_GetLastEvent
   \   00000256   0x0740             LSLS     R0,R0,#+29
   \   00000258   0xD5FA             BPL.N    ??HW_I2C_Read_29
    203                  /* Clear ACK */
    204                  I2C_AcknowledgeConfig(I2Cx, DISABLE);
   \   0000025A   0x2100             MOVS     R1,#+0
   \   0000025C   0x0020             MOVS     R0,R4
   \   0000025E   0x.... 0x....      BL       I2C_AcknowledgeConfig
    205                  __disable_irq();
   \   00000262   0xB672             CPSID    I
    206                  /* Read Data N-2 */
    207                  *pBuffer = I2C_ReceiveData(I2Cx);
   \   00000264   0x0020             MOVS     R0,R4
   \   00000266   0x.... 0x....      BL       I2C_ReceiveData
   \   0000026A   0x7030             STRB     R0,[R6, #+0]
    208                  pBuffer++;
   \   0000026C   0x1C75             ADDS     R5,R6,#+1
    209                  /* Program the STOP */
    210                  I2C_GenerateSTOP(I2Cx, ENABLE);
   \   0000026E   0x2101             MOVS     R1,#+1
   \   00000270   0x0020             MOVS     R0,R4
   \   00000272   0x.... 0x....      BL       I2C_GenerateSTOP
    211                  /* Read DataN-1 */
    212                  *pBuffer = I2C_ReceiveData(I2Cx);
   \   00000276   0x0020             MOVS     R0,R4
   \   00000278   0x.... 0x....      BL       I2C_ReceiveData
   \   0000027C   0x7028             STRB     R0,[R5, #+0]
    213                  __enable_irq();
   \   0000027E   0xB662             CPSIE    I
    214                  pBuffer++;
   \   00000280   0x1C6E             ADDS     R6,R5,#+1
    215                  while ((I2C_GetLastEvent(I2Cx) & 0x00000040) != 0x0000040); /* Poll on RxNE */
   \                     ??HW_I2C_Read_30: (+1)
   \   00000282   0x0020             MOVS     R0,R4
   \   00000284   0x.... 0x....      BL       I2C_GetLastEvent
   \   00000288   0x0640             LSLS     R0,R0,#+25
   \   0000028A   0xD5FA             BPL.N    ??HW_I2C_Read_30
    216                  /* Read DataN */
    217                  *pBuffer = I2Cx->DR;
   \   0000028C   0x8A20             LDRH     R0,[R4, #+16]
   \   0000028E   0x7030             STRB     R0,[R6, #+0]
    218                  /* Reset the number of bytes to be read by master */
    219                  NumByteToRead = 0;
   \   00000290   0x2700             MOVS     R7,#+0
    220                }
    221              }
   \                     ??HW_I2C_Read_23: (+1)
   \   00000292   0x0038             MOVS     R0,R7
   \   00000294   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000296   0x2800             CMP      R0,#+0
   \   00000298   0xD1C7             BNE.N    ??HW_I2C_Read_26
    222              /* Make sure that the STOP bit is cleared by Hardware before CR1 write access */
    223              while ((I2Cx->CR1&0x200) == 0x200);
   \                     ??HW_I2C_Read_31: (+1)
   \   0000029A   0x8820             LDRH     R0,[R4, #+0]
   \   0000029C   0x0580             LSLS     R0,R0,#+22
   \   0000029E   0xD4FC             BMI.N    ??HW_I2C_Read_31
    224              /* Enable Acknowledgement to be ready for another reception */
    225              I2C_AcknowledgeConfig(I2Cx, ENABLE);
   \   000002A0   0x2101             MOVS     R1,#+1
   \   000002A2   0x0020             MOVS     R0,R4
   \   000002A4   0x.... 0x....      BL       I2C_AcknowledgeConfig
    226          
    227              return SUCCESS;
   \   000002A8   0x2001             MOVS     R0,#+1
   \                     ??HW_I2C_Read_6: (+1)
   \   000002AA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    228            }
    229          }
    230          

   \                                 In section .text, align 2, keep-with-next
    231          uint8_t HW_I2C_Write(I2C_TypeDef* I2Cx, uint8_t DeviceAddr, uint8_t RegisterAddr,
    232                                         uint16_t NumByteToWrite,
    233                                         uint8_t* pBuffer)
    234          {
   \                     HW_I2C_Write: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x001D             MOVS     R5,R3
    235            __IO uint32_t UTIL_Timeout = LONG_TIMEOUT;
   \   0000000A   0xF44F 0x4020      MOV      R0,#+40960
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0xE019             B.N      ??HW_I2C_Write_0
    236          
    237           restart1:
    238            UTIL_Timeout = LONG_TIMEOUT;
    239            /* Send START condition */
    240            I2C_GenerateSTART(I2Cx, ENABLE);
    241            /* Test on EV5 and clear it */
    242            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
    243            {
    244              if (UTIL_Timeout-- == 0) return ERROR;
    245            }
    246            /* Send slave address for write */
    247            I2C_Send7bitAddress(I2Cx, DeviceAddr, I2C_Direction_Transmitter);
   \                     ??HW_I2C_Write_1: (+1)
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x0031             MOVS     R1,R6
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       I2C_Send7bitAddress
    248          
    249            UTIL_Timeout = LONG_TIMEOUT;
   \   0000001E   0xF44F 0x4020      MOV      R0,#+40960
   \   00000022   0x9000             STR      R0,[SP, #+0]
    250            /* Test on EV6 and clear it */
    251            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??HW_I2C_Write_2: (+1)
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable10_6  ;; 0x70082
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       I2C_CheckEvent
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD11E             BNE.N    ??HW_I2C_Write_3
    252             {
    253          
    254              if (UTIL_Timeout-- == 0)
   \                     ??HW_I2C_Write_4: (+1)
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0x1E41             SUBS     R1,R0,#+1
   \   00000036   0x9100             STR      R1,[SP, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1F3             BNE.N    ??HW_I2C_Write_2
    255              {
    256                I2C_ClearFlag(I2Cx,I2C_FLAG_BUSY|I2C_FLAG_AF);
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable10_7  ;; 0x10020400
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       I2C_ClearFlag
    257                goto restart1;
    258              }
    259            }
   \                     ??HW_I2C_Write_0: (+1)
   \   00000046   0xF44F 0x4020      MOV      R0,#+40960
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       I2C_GenerateSTART
   \                     ??HW_I2C_Write_5: (+1)
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable10_8  ;; 0x30001
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       I2C_CheckEvent
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD1D7             BNE.N    ??HW_I2C_Write_1
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x1E41             SUBS     R1,R0,#+1
   \   00000066   0x9100             STR      R1,[SP, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD1F3             BNE.N    ??HW_I2C_Write_5
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE061             B.N      ??HW_I2C_Write_6
    260            
    261            UTIL_Timeout = LONG_TIMEOUT;
   \                     ??HW_I2C_Write_3: (+1)
   \   00000070   0xF44F 0x4020      MOV      R0,#+40960
   \   00000074   0x9000             STR      R0,[SP, #+0]
    262          
    263            /* Transmit the first address for r/w operations */
    264            I2C_SendData(I2Cx, RegisterAddr);
   \   00000076   0x0039             MOVS     R1,R7
   \   00000078   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       I2C_SendData
    265          
    266            /* Test on EV8 and clear it */
    267            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??HW_I2C_Write_7: (+1)
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable10_9  ;; 0x70084
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       I2C_CheckEvent
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD106             BNE.N    ??HW_I2C_Write_8
    268            {
    269              if (UTIL_Timeout-- == 0)
   \   0000008E   0x9800             LDR      R0,[SP, #+0]
   \   00000090   0x1E41             SUBS     R1,R0,#+1
   \   00000092   0x9100             STR      R1,[SP, #+0]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD1F3             BNE.N    ??HW_I2C_Write_7
    270                return ERROR;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xE04B             B.N      ??HW_I2C_Write_6
    271            }
   \                     ??HW_I2C_Write_8: (+1)
   \   0000009C   0x9E06             LDR      R6,[SP, #+24]
    272            if (NumByteToWrite == 0x01)
   \   0000009E   0x0028             MOVS     R0,R5
   \   000000A0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A2   0x2801             CMP      R0,#+1
   \   000000A4   0xD11A             BNE.N    ??HW_I2C_Write_9
    273            {
    274              UTIL_Timeout = LONG_TIMEOUT;
   \   000000A6   0xF44F 0x4020      MOV      R0,#+40960
   \   000000AA   0x9000             STR      R0,[SP, #+0]
    275              /* Prepare the register value to be sent */
    276              I2C_SendData(I2Cx, *pBuffer);
   \   000000AC   0x7831             LDRB     R1,[R6, #+0]
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       I2C_SendData
    277          
    278              /* Test on EV8 and clear it */
    279              while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??HW_I2C_Write_10: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable10_9  ;; 0x70084
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       I2C_CheckEvent
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD106             BNE.N    ??HW_I2C_Write_11
    280              {
    281                if (UTIL_Timeout-- == 0)
   \   000000C2   0x9800             LDR      R0,[SP, #+0]
   \   000000C4   0x1E41             SUBS     R1,R0,#+1
   \   000000C6   0x9100             STR      R1,[SP, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD1F3             BNE.N    ??HW_I2C_Write_10
    282                  return ERROR;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xE031             B.N      ??HW_I2C_Write_6
    283              }
    284          
    285              /* End the configuration sequence */
    286              I2C_GenerateSTOP(I2Cx, ENABLE);
   \                     ??HW_I2C_Write_11: (+1)
   \   000000D0   0x2101             MOVS     R1,#+1
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       I2C_GenerateSTOP
    287              return SUCCESS;
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xE02B             B.N      ??HW_I2C_Write_6
    288            }
    289            I2C_SendData(I2Cx, *pBuffer);
   \                     ??HW_I2C_Write_9: (+1)
   \   000000DC   0x7831             LDRB     R1,[R6, #+0]
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       I2C_SendData
    290            pBuffer++;
   \   000000E4   0x1C76             ADDS     R6,R6,#+1
    291            NumByteToWrite--;
   \   000000E6   0x1E6D             SUBS     R5,R5,#+1
   \   000000E8   0xE009             B.N      ??HW_I2C_Write_12
    292            /* While there is data to be written */
    293            while (NumByteToWrite--)
    294            {
    295              while ((I2C_GetLastEvent(I2Cx) & 0x04) != 0x04);  /* Poll on BTF */
   \                     ??HW_I2C_Write_13: (+1)
   \   000000EA   0x0020             MOVS     R0,R4
   \   000000EC   0x.... 0x....      BL       I2C_GetLastEvent
   \   000000F0   0x0740             LSLS     R0,R0,#+29
   \   000000F2   0xD5FA             BPL.N    ??HW_I2C_Write_13
    296              /* Send the current byte */
    297              I2C_SendData(I2Cx, *pBuffer);
   \   000000F4   0x7831             LDRB     R1,[R6, #+0]
   \   000000F6   0x0020             MOVS     R0,R4
   \   000000F8   0x.... 0x....      BL       I2C_SendData
    298              /* Point to the next byte to be written */
    299              pBuffer++;
   \   000000FC   0x1C76             ADDS     R6,R6,#+1
    300          
    301            }
   \                     ??HW_I2C_Write_12: (+1)
   \   000000FE   0x0028             MOVS     R0,R5
   \   00000100   0x1E45             SUBS     R5,R0,#+1
   \   00000102   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD1F0             BNE.N    ??HW_I2C_Write_13
    302            UTIL_Timeout = LONG_TIMEOUT;
   \   00000108   0xF44F 0x4020      MOV      R0,#+40960
   \   0000010C   0x9000             STR      R0,[SP, #+0]
    303            /* Test on EV8_2 and clear it, BTF = TxE = 1, DR and shift registers are
    304             empty */
    305            while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??HW_I2C_Write_14: (+1)
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable10_9  ;; 0x70084
   \   00000112   0x0020             MOVS     R0,R4
   \   00000114   0x.... 0x....      BL       I2C_CheckEvent
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD106             BNE.N    ??HW_I2C_Write_15
    306            {
    307              if (UTIL_Timeout-- == 0) return ERROR;
   \   0000011C   0x9800             LDR      R0,[SP, #+0]
   \   0000011E   0x1E41             SUBS     R1,R0,#+1
   \   00000120   0x9100             STR      R1,[SP, #+0]
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD1F3             BNE.N    ??HW_I2C_Write_14
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xE004             B.N      ??HW_I2C_Write_6
    308            }
    309            /* Send STOP condition */
    310            I2C_GenerateSTOP(I2Cx, ENABLE);
   \                     ??HW_I2C_Write_15: (+1)
   \   0000012A   0x2101             MOVS     R1,#+1
   \   0000012C   0x0020             MOVS     R0,R4
   \   0000012E   0x.... 0x....      BL       I2C_GenerateSTOP
    311            return SUCCESS;
   \   00000132   0x2001             MOVS     R0,#+1
   \                     ??HW_I2C_Write_6: (+1)
   \   00000134   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    312          }
    313          
    314          /*
    315          DS3231@@@ @@ @ @@ @@@@ @@@@ @@
    316          @@ @@@ @@@ @(@@ @@@->hour_select->am_pm_24)@ @@@
    317          AM, PM, 24@@ @@@ @@@ @ @@
    318          */

   \                                 In section .text, align 2, keep-with-next
    319          void ds3231_print_time(ds3231_time *current_time)
    320          {
   \                     ds3231_print_time: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
    321                  char time[20] = "";
   \   00000006   0xA803             ADD      R0,SP,#+12
   \   00000008   0x2114             MOVS     R1,#+20
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr
    322                  char sprin_result[5] = "";
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x2105             MOVS     R1,#+5
   \   00000012   0x.... 0x....      BL       __aeabi_memclr
    323                  
    324          	printf("%d-%d-%d",current_time->year,current_time->month
    325          			,current_time->date);
   \   00000016   0x7963             LDRB     R3,[R4, #+5]
   \   00000018   0x79A2             LDRB     R2,[R4, #+6]
   \   0000001A   0x79E1             LDRB     R1,[R4, #+7]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable10_12
   \   00000020   0x.... 0x....      BL       printf
    326                  
    327                  sprintf(sprin_result, "%d", current_time->year);
   \   00000024   0x79E2             LDRB     R2,[R4, #+7]
   \   00000026   0x....             ADR.N    R1,??DataTable6  ;; 0x25, 0x64, 0x00, 0x00
   \   00000028   0xA801             ADD      R0,SP,#+4
   \   0000002A   0x.... 0x....      BL       sprintf
    328                  strcat(time, sprin_result);
   \   0000002E   0xA901             ADD      R1,SP,#+4
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x.... 0x....      BL       strcat
    329                  strcat(time, "-");
   \   00000036   0x....             ADR.N    R1,??DataTable6_1  ;; "-"
   \   00000038   0x.... 0x....      BL       strcat
    330                  sprintf(sprin_result, "%d", current_time->month);
   \   0000003C   0x79A2             LDRB     R2,[R4, #+6]
   \   0000003E   0x....             ADR.N    R1,??DataTable6  ;; 0x25, 0x64, 0x00, 0x00
   \   00000040   0xA801             ADD      R0,SP,#+4
   \   00000042   0x.... 0x....      BL       sprintf
    331                  strcat(time, sprin_result);
   \   00000046   0xA901             ADD      R1,SP,#+4
   \   00000048   0xA803             ADD      R0,SP,#+12
   \   0000004A   0x.... 0x....      BL       strcat
    332                  strcat(time, "-");
   \   0000004E   0x....             ADR.N    R1,??DataTable6_1  ;; "-"
   \   00000050   0x.... 0x....      BL       strcat
    333                  sprintf(sprin_result, "%d", current_time->date);
   \   00000054   0x7962             LDRB     R2,[R4, #+5]
   \   00000056   0x....             ADR.N    R1,??DataTable6  ;; 0x25, 0x64, 0x00, 0x00
   \   00000058   0xA801             ADD      R0,SP,#+4
   \   0000005A   0x.... 0x....      BL       sprintf
    334                  strcat(time, sprin_result);
   \   0000005E   0xA901             ADD      R1,SP,#+4
   \   00000060   0xA803             ADD      R0,SP,#+12
   \   00000062   0x.... 0x....      BL       strcat
    335                  strcat(time, " ");
   \   00000066   0x....             ADR.N    R1,??DataTable6_2  ;; " "
   \   00000068   0x.... 0x....      BL       strcat
    336                  
    337          	switch (current_time->hour_select.am_pm_24)
   \   0000006C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD003             BEQ.N    ??ds3231_print_time_0
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD037             BEQ.N    ??ds3231_print_time_1
   \   00000076   0xD31B             BCC.N    ??ds3231_print_time_2
   \   00000078   0xE04C             B.N      ??ds3231_print_time_3
    338          	{
    339          		//12@@ @@@ @@ 0~4@ @@@@ @@@ @@ @@@, 5~6@ @@@ @@ @@ @@ @@
    340          		case ds3231_AM :
    341                            printf("AM : %d:",(current_time->hour_select.hour)&0x1F);	
   \                     ??ds3231_print_time_0: (+1)
   \   0000007A   0x78E1             LDRB     R1,[R4, #+3]
   \   0000007C   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable10_13
   \   00000084   0x.... 0x....      BL       printf
    342                            strcat(time, "AM : ");
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable10_14
   \   0000008C   0xA803             ADD      R0,SP,#+12
   \   0000008E   0x.... 0x....      BL       strcat
    343                            sprintf(sprin_result, "%d", (current_time->hour_select.hour)&0x1F);
   \   00000092   0x78E2             LDRB     R2,[R4, #+3]
   \   00000094   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   00000098   0x....             ADR.N    R1,??DataTable6  ;; 0x25, 0x64, 0x00, 0x00
   \   0000009A   0xA801             ADD      R0,SP,#+4
   \   0000009C   0x.... 0x....      BL       sprintf
    344                            strcat(time, sprin_result);
   \   000000A0   0xA901             ADD      R1,SP,#+4
   \   000000A2   0xA803             ADD      R0,SP,#+12
   \   000000A4   0x.... 0x....      BL       strcat
    345                            strcat(time, ":");
   \   000000A8   0x....             ADR.N    R1,??DataTable6_3  ;; ":"
   \   000000AA   0x.... 0x....      BL       strcat
    346          			break;
   \   000000AE   0xE031             B.N      ??ds3231_print_time_4
    347          		case ds3231_PM :
    348                            printf("PM : %d:",(current_time->hour_select.hour)&0x1F);
   \                     ??ds3231_print_time_2: (+1)
   \   000000B0   0x78E1             LDRB     R1,[R4, #+3]
   \   000000B2   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable10_15
   \   000000BA   0x.... 0x....      BL       printf
    349                            strcat(time, "PM : ");
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable10_16
   \   000000C2   0xA803             ADD      R0,SP,#+12
   \   000000C4   0x.... 0x....      BL       strcat
    350                            sprintf(sprin_result, "%d", (current_time->hour_select.hour)&0x1F);
   \   000000C8   0x78E2             LDRB     R2,[R4, #+3]
   \   000000CA   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   000000CE   0x....             ADR.N    R1,??DataTable6  ;; 0x25, 0x64, 0x00, 0x00
   \   000000D0   0xA801             ADD      R0,SP,#+4
   \   000000D2   0x.... 0x....      BL       sprintf
    351                            strcat(time, sprin_result);
   \   000000D6   0xA901             ADD      R1,SP,#+4
   \   000000D8   0xA803             ADD      R0,SP,#+12
   \   000000DA   0x.... 0x....      BL       strcat
    352                            strcat(time, ":");
   \   000000DE   0x....             ADR.N    R1,??DataTable6_3  ;; ":"
   \   000000E0   0x.... 0x....      BL       strcat
    353          			break;
   \   000000E4   0xE016             B.N      ??ds3231_print_time_4
    354          		case ds3231_24_hour :
    355                            printf("24 : %d:",current_time->hour_select.hour);
   \                     ??ds3231_print_time_1: (+1)
   \   000000E6   0x78E1             LDRB     R1,[R4, #+3]
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable10_17
   \   000000EC   0x.... 0x....      BL       printf
    356                            strcat(time, "24 : ");
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable10_18
   \   000000F4   0xA803             ADD      R0,SP,#+12
   \   000000F6   0x.... 0x....      BL       strcat
    357                            sprintf(sprin_result, "%d", current_time->hour_select.hour);
   \   000000FA   0x78E2             LDRB     R2,[R4, #+3]
   \   000000FC   0x....             ADR.N    R1,??DataTable6  ;; 0x25, 0x64, 0x00, 0x00
   \   000000FE   0xA801             ADD      R0,SP,#+4
   \   00000100   0x.... 0x....      BL       sprintf
    358                            strcat(time, sprin_result);
   \   00000104   0xA901             ADD      R1,SP,#+4
   \   00000106   0xA803             ADD      R0,SP,#+12
   \   00000108   0x.... 0x....      BL       strcat
    359                            strcat(time, ":");
   \   0000010C   0x....             ADR.N    R1,??DataTable6_3  ;; ":"
   \   0000010E   0x.... 0x....      BL       strcat
    360          			break;
   \   00000112   0xE7FF             B.N      ??ds3231_print_time_4
    361          		default :
    362          			break;
    363          	}
    364                  
    365          	printf("%d:%d\r\n",current_time->min,current_time->sec);
   \                     ??ds3231_print_time_3: (+1)
   \                     ??ds3231_print_time_4: (+1)
   \   00000114   0x7822             LDRB     R2,[R4, #+0]
   \   00000116   0x7861             LDRB     R1,[R4, #+1]
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable10_19
   \   0000011C   0x.... 0x....      BL       printf
    366                  
    367                  sprintf(sprin_result, "%d", current_time->min);
   \   00000120   0x7862             LDRB     R2,[R4, #+1]
   \   00000122   0x....             ADR.N    R1,??DataTable6  ;; 0x25, 0x64, 0x00, 0x00
   \   00000124   0xA801             ADD      R0,SP,#+4
   \   00000126   0x.... 0x....      BL       sprintf
    368                  strcat(time, sprin_result);
   \   0000012A   0xA901             ADD      R1,SP,#+4
   \   0000012C   0xA803             ADD      R0,SP,#+12
   \   0000012E   0x.... 0x....      BL       strcat
    369                  strcat(time, ":");
   \   00000132   0x....             ADR.N    R1,??DataTable6_3  ;; ":"
   \   00000134   0x.... 0x....      BL       strcat
    370                  sprintf(sprin_result, "%d", current_time->sec);
   \   00000138   0x7822             LDRB     R2,[R4, #+0]
   \   0000013A   0x....             ADR.N    R1,??DataTable6  ;; 0x25, 0x64, 0x00, 0x00
   \   0000013C   0xA801             ADD      R0,SP,#+4
   \   0000013E   0x.... 0x....      BL       sprintf
    371                  strcat(time, sprin_result);
   \   00000142   0xA901             ADD      R1,SP,#+4
   \   00000144   0xA803             ADD      R0,SP,#+12
   \   00000146   0x.... 0x....      BL       strcat
   \   0000014A   0x0001             MOVS     R1,R0
    372                  
    373                  printf("String : %s\n", time);
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable10_20
   \   00000150   0x.... 0x....      BL       printf
    374                  
    375                  LCD_ShowString(25, 100, time, BLACK, WHITE);
                                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "u8 *"
   \   00000154   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000158   0x9000             STR      R0,[SP, #+0]
   \   0000015A   0x2300             MOVS     R3,#+0
   \   0000015C   0xAA03             ADD      R2,SP,#+12
   \   0000015E   0x2164             MOVS     R1,#+100
   \   00000160   0x2019             MOVS     R0,#+25
   \   00000162   0x.... 0x....      BL       LCD_ShowString
    376          
    377          }
   \   00000166   0xB008             ADD      SP,SP,#+32
   \   00000168   0xBD10             POP      {R4,PC}          ;; return
    378          
    379          /*
    380          @@@@ @@ @@@ @@@ DS3231@@@ @@ @ @@ @@@@ @@@@ @@
    381          */

   \                                 In section .text, align 2, keep-with-next
    382          void ds3231_read_time(ds3231_time *current_time)
    383          {
   \                     ds3231_read_time: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    384          	uint8_t ds3231_read_time_buff[7];	
    385          	//DS3231@@@ @@ @ @@@@ @@@ @@@ @@ (@,@,@@,@@,@@,@,@@-@ 7@)
    386          
    387          	/*
    388          	@@ @@@ @@@ @@@@@ @@@ @@@@ @@@@ @@@@ @@@ @@@ @@
    389          	*/
    390          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_sec_addr, 1, &ds3231_read_time_buff[0]);
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x9000             STR      R0,[SP, #+0]
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x21D0             MOVS     R1,#+208
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x40005400
   \   00000012   0x.... 0x....      BL       HW_I2C_Read
    391          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_min_addr, 1, &ds3231_read_time_buff[1]);
   \   00000016   0xF10D 0x0005      ADD      R0,SP,#+5
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x21D0             MOVS     R1,#+208
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x40005400
   \   00000026   0x.... 0x....      BL       HW_I2C_Read
    392          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_hour_addr, 1, &ds3231_read_time_buff[2]);
   \   0000002A   0xF10D 0x0006      ADD      R0,SP,#+6
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x2301             MOVS     R3,#+1
   \   00000032   0x2202             MOVS     R2,#+2
   \   00000034   0x21D0             MOVS     R1,#+208
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x40005400
   \   0000003A   0x.... 0x....      BL       HW_I2C_Read
    393          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_day_addr, 1, &ds3231_read_time_buff[3]);
   \   0000003E   0xF10D 0x0007      ADD      R0,SP,#+7
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x2301             MOVS     R3,#+1
   \   00000046   0x2203             MOVS     R2,#+3
   \   00000048   0x21D0             MOVS     R1,#+208
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x40005400
   \   0000004E   0x.... 0x....      BL       HW_I2C_Read
    394          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_date_addr, 1, &ds3231_read_time_buff[4]);
   \   00000052   0xA802             ADD      R0,SP,#+8
   \   00000054   0x9000             STR      R0,[SP, #+0]
   \   00000056   0x2301             MOVS     R3,#+1
   \   00000058   0x2204             MOVS     R2,#+4
   \   0000005A   0x21D0             MOVS     R1,#+208
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x40005400
   \   00000060   0x.... 0x....      BL       HW_I2C_Read
    395          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_month_addr, 1, &ds3231_read_time_buff[5]);
   \   00000064   0xF10D 0x0009      ADD      R0,SP,#+9
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x2301             MOVS     R3,#+1
   \   0000006C   0x2205             MOVS     R2,#+5
   \   0000006E   0x21D0             MOVS     R1,#+208
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x40005400
   \   00000074   0x.... 0x....      BL       HW_I2C_Read
    396          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_year_addr, 1, &ds3231_read_time_buff[6]);
   \   00000078   0xF10D 0x000A      ADD      R0,SP,#+10
   \   0000007C   0x9000             STR      R0,[SP, #+0]
   \   0000007E   0x2301             MOVS     R3,#+1
   \   00000080   0x2206             MOVS     R2,#+6
   \   00000082   0x21D0             MOVS     R1,#+208
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x40005400
   \   00000088   0x.... 0x....      BL       HW_I2C_Read
    397          	//@@@ I2C, DS3231 @@, @@@ DS3231 @@@@ @@, @@@ @@ @@, @@ @ @@@@ @@@ @@,
    398          	//@@ @ @@@ @@
    399              
    400          		//@@ @@ @@@ @@
    401                  
    402          	/*
    403          	DS3231@@@ @@ @ @@@@ 10@@@ @@@ @ @@@@ @@@@ @@
    404          	*/
    405          	current_time->sec=bcdTodec(ds3231_read_time_buff[0]);
   \   0000008C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000090   0x.... 0x....      BL       bcdTodec
   \   00000094   0x7020             STRB     R0,[R4, #+0]
    406          	current_time->min=bcdTodec(ds3231_read_time_buff[1]);
   \   00000096   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000009A   0x.... 0x....      BL       bcdTodec
   \   0000009E   0x7060             STRB     R0,[R4, #+1]
    407          
    408          	/*
    409          	@@ @@@@(0x02)@@@ @@ @ @@@@ 6@ @@(0x40), 5@ @@(0x20)@ @@@ 
    410          	High(1)@ @@@@@ @@ @@@ @@@ AM, PM @@@ @@ (24@@ @@@ @@ 6@ @@ Low(0))
    411          	*/
    412          	if((ds3231_read_time_buff[2]&0x40)!=0)	//BIT6!=0 @@@ 12@@ @@
   \   000000A0   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   000000A4   0x0640             LSLS     R0,R0,#+25
   \   000000A6   0xD508             BPL.N    ??ds3231_read_time_0
    413          	{
    414          		if((ds3231_read_time_buff[2]&0x20)==0)	//BIT5==0 @@@ AM
   \   000000A8   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   000000AC   0x0680             LSLS     R0,R0,#+26
   \   000000AE   0xD402             BMI.N    ??ds3231_read_time_1
    415          		{
    416          			current_time->hour_select.am_pm_24=ds3231_AM;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x70A0             STRB     R0,[R4, #+2]
   \   000000B4   0xE001             B.N      ??ds3231_read_time_0
    417          		}
    418          		else	//BIT5!=0 @@@ PM
    419          		{
    420          			current_time->hour_select.am_pm_24=ds3231_PM;
   \                     ??ds3231_read_time_1: (+1)
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x70A0             STRB     R0,[R4, #+2]
    421          		}
    422          	}
    423          	else
    424          	{
    425          		//24@@ @@ @@@ @@ (6@ @@ 0, 5@ @@ 2x @@@ @@ 1)
    426          	}
    427                  
    428          	current_time->hour_select.hour=bcdTodec(ds3231_read_time_buff[2]);
   \                     ??ds3231_read_time_0: (+1)
   \   000000BA   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   000000BE   0x.... 0x....      BL       bcdTodec
   \   000000C2   0x70E0             STRB     R0,[R4, #+3]
    429                  
    430          	current_time->day=bcdTodec(ds3231_read_time_buff[3]);
   \   000000C4   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   000000C8   0x.... 0x....      BL       bcdTodec
   \   000000CC   0x7120             STRB     R0,[R4, #+4]
    431          	current_time->date=bcdTodec(ds3231_read_time_buff[4]);
   \   000000CE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000D2   0x.... 0x....      BL       bcdTodec
   \   000000D6   0x7160             STRB     R0,[R4, #+5]
    432          	current_time->month=bcdTodec(ds3231_read_time_buff[5]);
   \   000000D8   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   000000DC   0x.... 0x....      BL       bcdTodec
   \   000000E0   0x71A0             STRB     R0,[R4, #+6]
    433          	current_time->year=bcdTodec(ds3231_read_time_buff[6]);
   \   000000E2   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   000000E6   0x.... 0x....      BL       bcdTodec
   \   000000EA   0x71E0             STRB     R0,[R4, #+7]
    434          
    435          }
   \   000000EC   0xBD1F             POP      {R0-R4,PC}       ;; return
    436          
    437          /*
    438          @@@@ @@@ @@@ @@ DS3231@ @@@ @@ @@@ @@@ @@
    439          */

   \                                 In section .text, align 2, keep-with-next
    440          void ds3231_write_time(ds3231_time *ds3231_write_time_struct)
    441          {
   \                     ds3231_write_time: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    442          	uint8_t write_buf[7];	//@@@ @@@ @@@ @@ @@ @@
    443          	
    444          	//@@@ 10@@ @@ @@@@ 2@@@
    445          	write_buf[0]=decTobcd(ds3231_write_time_struct->sec);
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       decTobcd
   \   0000000A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    446          	write_buf[1]=decTobcd(ds3231_write_time_struct->min);
   \   0000000E   0x7860             LDRB     R0,[R4, #+1]
   \   00000010   0x.... 0x....      BL       decTobcd
   \   00000014   0xF88D 0x0005      STRB     R0,[SP, #+5]
    447          	write_buf[2]=decTobcd(ds3231_write_time_struct->hour_select.hour);
   \   00000018   0x78E0             LDRB     R0,[R4, #+3]
   \   0000001A   0x.... 0x....      BL       decTobcd
   \   0000001E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    448          	write_buf[3]=decTobcd(ds3231_write_time_struct->day);
   \   00000022   0x7920             LDRB     R0,[R4, #+4]
   \   00000024   0x.... 0x....      BL       decTobcd
   \   00000028   0xF88D 0x0007      STRB     R0,[SP, #+7]
    449          	write_buf[4]=decTobcd(ds3231_write_time_struct->date);
   \   0000002C   0x7960             LDRB     R0,[R4, #+5]
   \   0000002E   0x.... 0x....      BL       decTobcd
   \   00000032   0xF88D 0x0008      STRB     R0,[SP, #+8]
    450          	write_buf[5]=decTobcd(ds3231_write_time_struct->month);
   \   00000036   0x79A0             LDRB     R0,[R4, #+6]
   \   00000038   0x.... 0x....      BL       decTobcd
   \   0000003C   0xF88D 0x0009      STRB     R0,[SP, #+9]
    451          	write_buf[6]=decTobcd(ds3231_write_time_struct->year);
   \   00000040   0x79E0             LDRB     R0,[R4, #+7]
   \   00000042   0x.... 0x....      BL       decTobcd
   \   00000046   0xF88D 0x000A      STRB     R0,[SP, #+10]
    452          
    453          	/*
    454          	24@@ @@@ @@ 12@@ @@(AM/PM)@ @@@@ @@@ 
    455          	DS3231 @@(Hour) @@@@(0x02)@ @@@ @@@@ @@@ 6, 5@ @@@ @@@@@ @@
    456          	*/
    457          	switch(ds3231_write_time_struct->hour_select.am_pm_24)
   \   0000004A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD003             BEQ.N    ??ds3231_write_time_0
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xD00F             BEQ.N    ??ds3231_write_time_1
   \   00000054   0xD307             BCC.N    ??ds3231_write_time_2
   \   00000056   0xE00E             B.N      ??ds3231_write_time_3
    458          	{
    459          		case ds3231_AM :	//AM@ @@ 6@ @@(12/24)@ High@ @@@@@ @@
    460          			write_buf[2]|=0x40;
   \                     ??ds3231_write_time_0: (+1)
   \   00000058   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000005C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000060   0xF88D 0x0006      STRB     R0,[SP, #+6]
    461          			break;
   \   00000064   0xE007             B.N      ??ds3231_write_time_4
    462          		case ds3231_PM :	//PM@ @@ 6, 5@ @@@ High@ @@@@@ @@
    463          			write_buf[2]|=0x60;
   \                     ??ds3231_write_time_2: (+1)
   \   00000066   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000006A   0xF050 0x0060      ORRS     R0,R0,#0x60
   \   0000006E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    464          			break;
   \   00000072   0xE000             B.N      ??ds3231_write_time_4
    465          		case ds3231_24_hour :
    466          			break;
   \                     ??ds3231_write_time_1: (+1)
   \   00000074   0xE7FF             B.N      ??ds3231_write_time_4
    467          		default :
    468          			break;
    469          	}
    470          
    471          	/*
    472          	DS3231 @(Sec) @@@@(0x00)@@ 7@@ 8@@ @@@ @@@ @@
    473          	@ @@ @@@@@ 8@@@ @@@ @@@@ 0x00@@ 0x06@@ @@@@@ 8@@ @@@ 7@@ @@@@
    474          	*/
    475                  
    476          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_sec_addr, 1, &write_buf[0]);
   \                     ??ds3231_write_time_3: (+1)
   \                     ??ds3231_write_time_4: (+1)
   \   00000076   0xA801             ADD      R0,SP,#+4
   \   00000078   0x9000             STR      R0,[SP, #+0]
   \   0000007A   0x2301             MOVS     R3,#+1
   \   0000007C   0x2200             MOVS     R2,#+0
   \   0000007E   0x21D0             MOVS     R1,#+208
   \   00000080   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   00000082   0x.... 0x....      BL       HW_I2C_Write
    477          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_min_addr, 1, &write_buf[1]);
   \   00000086   0xF10D 0x0005      ADD      R0,SP,#+5
   \   0000008A   0x9000             STR      R0,[SP, #+0]
   \   0000008C   0x2301             MOVS     R3,#+1
   \   0000008E   0x2201             MOVS     R2,#+1
   \   00000090   0x21D0             MOVS     R1,#+208
   \   00000092   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   00000094   0x.... 0x....      BL       HW_I2C_Write
    478          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_hour_addr, 1, &write_buf[2]);
   \   00000098   0xF10D 0x0006      ADD      R0,SP,#+6
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0x2301             MOVS     R3,#+1
   \   000000A0   0x2202             MOVS     R2,#+2
   \   000000A2   0x21D0             MOVS     R1,#+208
   \   000000A4   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   000000A6   0x.... 0x....      BL       HW_I2C_Write
    479          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_day_addr, 1, &write_buf[3]);
   \   000000AA   0xF10D 0x0007      ADD      R0,SP,#+7
   \   000000AE   0x9000             STR      R0,[SP, #+0]
   \   000000B0   0x2301             MOVS     R3,#+1
   \   000000B2   0x2203             MOVS     R2,#+3
   \   000000B4   0x21D0             MOVS     R1,#+208
   \   000000B6   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   000000B8   0x.... 0x....      BL       HW_I2C_Write
    480          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_date_addr, 1, &write_buf[4]);
   \   000000BC   0xA802             ADD      R0,SP,#+8
   \   000000BE   0x9000             STR      R0,[SP, #+0]
   \   000000C0   0x2301             MOVS     R3,#+1
   \   000000C2   0x2204             MOVS     R2,#+4
   \   000000C4   0x21D0             MOVS     R1,#+208
   \   000000C6   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   000000C8   0x.... 0x....      BL       HW_I2C_Write
    481          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_month_addr, 1, &write_buf[5]);
   \   000000CC   0xF10D 0x0009      ADD      R0,SP,#+9
   \   000000D0   0x9000             STR      R0,[SP, #+0]
   \   000000D2   0x2301             MOVS     R3,#+1
   \   000000D4   0x2205             MOVS     R2,#+5
   \   000000D6   0x21D0             MOVS     R1,#+208
   \   000000D8   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   000000DA   0x.... 0x....      BL       HW_I2C_Write
    482          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_year_addr, 1, &write_buf[6]);
   \   000000DE   0xF10D 0x000A      ADD      R0,SP,#+10
   \   000000E2   0x9000             STR      R0,[SP, #+0]
   \   000000E4   0x2301             MOVS     R3,#+1
   \   000000E6   0x2206             MOVS     R2,#+6
   \   000000E8   0x21D0             MOVS     R1,#+208
   \   000000EA   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   000000EC   0x.... 0x....      BL       HW_I2C_Write
    483                  
    484          		//@@ @@@@ @@
    485          }
   \   000000F0   0xBD1F             POP      {R0-R4,PC}       ;; return
    486          

   \                                 In section .text, align 2, keep-with-next
    487          void ds3231_set_alarm1(ds3231_Alarm1 *alarm1_data)
    488          {
   \                     ds3231_set_alarm1: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    489          	uint8_t alarm1_buff[4];	//DS3231@ @@@ @@1 @@@ @@
    490          
    491          	alarm1_buff[0]=decTobcd(alarm1_data->sec);	//@
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       decTobcd
   \   0000000A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    492          	alarm1_buff[1]=decTobcd(alarm1_data->min);	//@
   \   0000000E   0x7860             LDRB     R0,[R4, #+1]
   \   00000010   0x.... 0x....      BL       decTobcd
   \   00000014   0xF88D 0x0005      STRB     R0,[SP, #+5]
    493          	alarm1_buff[2]=decTobcd(alarm1_data->hour_select.hour);	//@@
   \   00000018   0x78E0             LDRB     R0,[R4, #+3]
   \   0000001A   0x.... 0x....      BL       decTobcd
   \   0000001E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    494          	alarm1_buff[3]=decTobcd(alarm1_data->day_date_select.value);	//@@ or @@@
   \   00000022   0x7960             LDRB     R0,[R4, #+5]
   \   00000024   0x.... 0x....      BL       decTobcd
   \   00000028   0xF88D 0x0007      STRB     R0,[SP, #+7]
    495          
    496          	/*
    497          	12/24 @@ @ AM, PM @@
    498          	*/
    499          	switch(alarm1_data->hour_select.am_pm_24)
   \   0000002C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD003             BEQ.N    ??ds3231_set_alarm1_0
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD00F             BEQ.N    ??ds3231_set_alarm1_1
   \   00000036   0xD307             BCC.N    ??ds3231_set_alarm1_2
   \   00000038   0xE00E             B.N      ??ds3231_set_alarm1_3
    500          	{
    501          		case ds3231_AM :	//@@@ @@@@ @@ @@@ AM@ @@
    502          			alarm1_buff[2]|=0x40;	//BIT6 Logic High=12@@ @@, BIT5 Logic Low=AM
   \                     ??ds3231_set_alarm1_0: (+1)
   \   0000003A   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000003E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000042   0xF88D 0x0006      STRB     R0,[SP, #+6]
    503          			break;
   \   00000046   0xE007             B.N      ??ds3231_set_alarm1_4
    504          		case ds3231_PM :	//@@@ @@@@ @@ @@@ PM@ @@
    505          			alarm1_buff[2]|=0x60;	//BIT6 Logic High=12@@ @@, BIT5 Logic High=PM
   \                     ??ds3231_set_alarm1_2: (+1)
   \   00000048   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000004C   0xF050 0x0060      ORRS     R0,R0,#0x60
   \   00000050   0xF88D 0x0006      STRB     R0,[SP, #+6]
    506          			break;
   \   00000054   0xE000             B.N      ??ds3231_set_alarm1_4
    507          		case ds3231_24_hour :	//@@@ @@@@ @@ @@@ 24@@ @@@ @@ (@@ @@ @@ X)
    508          			break;
   \                     ??ds3231_set_alarm1_1: (+1)
   \   00000056   0xE7FF             B.N      ??ds3231_set_alarm1_4
    509          		default :
    510          			break;
    511          	}
    512          
    513          	/*
    514          	@@ @@@ @@@ @@ @@@ @@@ @@@ @@
    515          	*/
    516          	switch(alarm1_data->day_date_select.day_or_date)
   \                     ??ds3231_set_alarm1_3: (+1)
   \                     ??ds3231_set_alarm1_4: (+1)
   \   00000058   0x7920             LDRB     R0,[R4, #+4]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD002             BEQ.N    ??ds3231_set_alarm1_5
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD001             BEQ.N    ??ds3231_set_alarm1_6
   \   00000062   0xE007             B.N      ??ds3231_set_alarm1_7
    517          	{
    518          		case ds3231_date :	//@@ @@, BIT6 - Low
    519          			break;
   \                     ??ds3231_set_alarm1_5: (+1)
   \   00000064   0xE006             B.N      ??ds3231_set_alarm1_8
    520          		case ds3231_day :
    521          			alarm1_buff[3]|=0x40;	//@@ @@, BIT6 - High
   \                     ??ds3231_set_alarm1_6: (+1)
   \   00000066   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   0000006A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000006E   0xF88D 0x0007      STRB     R0,[SP, #+7]
    522          			break;
   \   00000072   0xE7FF             B.N      ??ds3231_set_alarm1_8
    523          		default :
    524          			break;
    525          	}
    526                  
    527          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_alarm1_sec_addr, 1, &alarm1_buff[0]);
   \                     ??ds3231_set_alarm1_7: (+1)
   \                     ??ds3231_set_alarm1_8: (+1)
   \   00000074   0xA801             ADD      R0,SP,#+4
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0x2301             MOVS     R3,#+1
   \   0000007A   0x2207             MOVS     R2,#+7
   \   0000007C   0x21D0             MOVS     R1,#+208
   \   0000007E   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   00000080   0x.... 0x....      BL       HW_I2C_Write
    528          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_alarm1_min_addr, 1, &alarm1_buff[1]);
   \   00000084   0xF10D 0x0005      ADD      R0,SP,#+5
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0x2301             MOVS     R3,#+1
   \   0000008C   0x2208             MOVS     R2,#+8
   \   0000008E   0x21D0             MOVS     R1,#+208
   \   00000090   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   00000092   0x.... 0x....      BL       HW_I2C_Write
    529          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_alarm1_hour_addr, 1, &alarm1_buff[2]);
   \   00000096   0xF10D 0x0006      ADD      R0,SP,#+6
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   \   0000009C   0x2301             MOVS     R3,#+1
   \   0000009E   0x2209             MOVS     R2,#+9
   \   000000A0   0x21D0             MOVS     R1,#+208
   \   000000A2   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   000000A4   0x.... 0x....      BL       HW_I2C_Write
    530          	HW_I2C_Write(I2C1, ds3231_addr, ds3231_alarm1_day_date_addr, 1, &alarm1_buff[3]);
   \   000000A8   0xF10D 0x0007      ADD      R0,SP,#+7
   \   000000AC   0x9000             STR      R0,[SP, #+0]
   \   000000AE   0x2301             MOVS     R3,#+1
   \   000000B0   0x220A             MOVS     R2,#+10
   \   000000B2   0x21D0             MOVS     R1,#+208
   \   000000B4   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   000000B6   0x.... 0x....      BL       HW_I2C_Write
    531                  
    532                  Alarm_flag = 0;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x....             LDR.N    R1,??DataTable10_21
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    533          }
   \   000000C0   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    534          

   \                                 In section .text, align 2, keep-with-next
    535          void ds3231_read_alarm1(ds3231_Alarm1 *current_alarm1)
    536          {
   \                     ds3231_read_alarm1: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    537          	uint8_t read_alarm1_buff[4];	//DS3231@@@ @@ @ @@1 @@@ @@@ @@@ @@
    538                  
    539                  
    540          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_alarm1_sec_addr, 1, &read_alarm1_buff[0]);
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x9000             STR      R0,[SP, #+0]
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x2207             MOVS     R2,#+7
   \   0000000C   0x21D0             MOVS     R1,#+208
   \   0000000E   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   00000010   0x.... 0x....      BL       HW_I2C_Read
    541          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_alarm1_min_addr, 1, &read_alarm1_buff[1]);
   \   00000014   0xF10D 0x0005      ADD      R0,SP,#+5
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x2301             MOVS     R3,#+1
   \   0000001C   0x2208             MOVS     R2,#+8
   \   0000001E   0x21D0             MOVS     R1,#+208
   \   00000020   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   00000022   0x.... 0x....      BL       HW_I2C_Read
    542          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_alarm1_hour_addr, 1, &read_alarm1_buff[2]);
   \   00000026   0xF10D 0x0006      ADD      R0,SP,#+6
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x2301             MOVS     R3,#+1
   \   0000002E   0x2209             MOVS     R2,#+9
   \   00000030   0x21D0             MOVS     R1,#+208
   \   00000032   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   00000034   0x.... 0x....      BL       HW_I2C_Read
    543          	HW_I2C_Read(I2C1, ds3231_addr,ds3231_alarm1_day_date_addr, 1, &read_alarm1_buff[3]);
   \   00000038   0xF10D 0x0007      ADD      R0,SP,#+7
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \   0000003E   0x2301             MOVS     R3,#+1
   \   00000040   0x220A             MOVS     R2,#+10
   \   00000042   0x21D0             MOVS     R1,#+208
   \   00000044   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40005400
   \   00000046   0x.... 0x....      BL       HW_I2C_Read
    544              
    545          	/*
    546          	@@@ @@@@ 10@@@ @@ @ @@@@ @@@@ @@
    547          	*/
    548          	current_alarm1->sec=bcdTodec(read_alarm1_buff[0]);
   \   0000004A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000004E   0x.... 0x....      BL       bcdTodec
   \   00000052   0x7020             STRB     R0,[R4, #+0]
    549          	current_alarm1->min=bcdTodec(read_alarm1_buff[1]);
   \   00000054   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000058   0x.... 0x....      BL       bcdTodec
   \   0000005C   0x7060             STRB     R0,[R4, #+1]
    550          
    551          	if((read_alarm1_buff[2]&0x40)!=0)	//12@@ @@@ @@@ @@
   \   0000005E   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000062   0x0640             LSLS     R0,R0,#+25
   \   00000064   0xD517             BPL.N    ??ds3231_read_alarm1_0
    552          	{
    553          		if((read_alarm1_buff[2]&0x20)==0)	//@@ @@ @@@ AM@ @@
   \   00000066   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000006A   0x0680             LSLS     R0,R0,#+26
   \   0000006C   0xD409             BMI.N    ??ds3231_read_alarm1_1
    554          		{
    555          			current_alarm1->hour_select.am_pm_24=ds3231_AM;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x70A0             STRB     R0,[R4, #+2]
    556          			current_alarm1->hour_select.hour=bcdTodec(read_alarm1_buff[2]&0x1F);
   \   00000072   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000076   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000007A   0x.... 0x....      BL       bcdTodec
   \   0000007E   0x70E0             STRB     R0,[R4, #+3]
   \   00000080   0xE00E             B.N      ??ds3231_read_alarm1_2
    557          			//12@@ @@@ @@@ @@, @@ @@@@@@ @@@ @@ @@@@ BIT 0 ~ BIT 4 @@
    558          		}
    559          		else	//@@ @@ @@@ PM@ @@
    560          		{
    561          			current_alarm1->hour_select.am_pm_24=ds3231_PM;
   \                     ??ds3231_read_alarm1_1: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x70A0             STRB     R0,[R4, #+2]
    562          			current_alarm1->hour_select.hour=bcdTodec(read_alarm1_buff[2]&0x1F);
   \   00000086   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000008A   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000008E   0x.... 0x....      BL       bcdTodec
   \   00000092   0x70E0             STRB     R0,[R4, #+3]
   \   00000094   0xE004             B.N      ??ds3231_read_alarm1_2
    563          		}
    564          	}
    565          	else	//24@@ @@
    566          	{
    567          		current_alarm1->hour_select.hour=bcdTodec(read_alarm1_buff[2]);	
   \                     ??ds3231_read_alarm1_0: (+1)
   \   00000096   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000009A   0x.... 0x....      BL       bcdTodec
   \   0000009E   0x70E0             STRB     R0,[R4, #+3]
    568          	}
    569          
    570          	if((read_alarm1_buff[3]&0x40)!=0)	//Day@ @@ (BIT 6 - High)
   \                     ??ds3231_read_alarm1_2: (+1)
   \   000000A0   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   000000A4   0x0640             LSLS     R0,R0,#+25
   \   000000A6   0xD509             BPL.N    ??ds3231_read_alarm1_3
    571          	{
    572          		current_alarm1->day_date_select.day_or_date=ds3231_day;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x7120             STRB     R0,[R4, #+4]
    573          		current_alarm1->day_date_select.value=bcdTodec(read_alarm1_buff[3]&0x0F);
   \   000000AC   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   000000B0   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000B4   0x.... 0x....      BL       bcdTodec
   \   000000B8   0x7160             STRB     R0,[R4, #+5]
   \   000000BA   0xE008             B.N      ??ds3231_read_alarm1_4
    574          		//Day @@@ @@, @@@ @@ @@@@ BIT 0 ~ BIT 3@@
    575          	}
    576          	else	//Date@ @@ (BIT 6 - Low)
    577          	{
    578          		current_alarm1->day_date_select.day_or_date=ds3231_date;
   \                     ??ds3231_read_alarm1_3: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x7120             STRB     R0,[R4, #+4]
    579          		current_alarm1->day_date_select.value=bcdTodec(read_alarm1_buff[3]&0x3F);
   \   000000C0   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   000000C4   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   000000C8   0x.... 0x....      BL       bcdTodec
   \   000000CC   0x7160             STRB     R0,[R4, #+5]
    580          		//Date @@@ @@, @@@ @@ @@@@ BIT 0 ~ BIT 5@@
    581          	}
    582          
    583          	//ds3231_print_alarm1(current_alarm1);	//@@ @ @@1 @@@@ @@@@ @@ @@ @@
    584          }
   \                     ??ds3231_read_alarm1_4: (+1)
   \   000000CE   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    585          

   \                                 In section .text, align 2, keep-with-next
    586          void Delay_little(void) {
    587             int i;
    588          
    589             for (i = 0; i < 200; i++) {}
   \                     Delay_little: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE000             B.N      ??Delay_little_0
   \                     ??Delay_little_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??Delay_little_0: (+1)
   \   00000006   0x28C8             CMP      R0,#+200
   \   00000008   0xDBFC             BLT.N    ??Delay_little_1
    590          }
   \   0000000A   0x4770             BX       LR               ;; return
    591          

   \                                 In section .text, align 2, keep-with-next
    592          void RCC_Configure_ds3231(void)
    593          {
   \                     RCC_Configure_ds3231: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    594            /* 1-1. TIM Clock Enable */
    595            //RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    596            /* 1-2. enable for PB7 */
    597            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);     // RCC GPIO B
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    598            RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);    // interrupt
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    599            /* 2. Enable for button -> use PD11 for s1 user */
    600            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE);     // RCC GPIO D
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2020             MOVS     R0,#+32
   \   00000016   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    601            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);     // RCC GPIO D
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2010             MOVS     R0,#+16
   \   0000001E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    602          }
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
    603          

   \                                 In section .text, align 2, keep-with-next
    604          void GPIO_Configure_ds3231(void)
    605          {
   \                     GPIO_Configure_ds3231: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    606             GPIO_InitTypeDef GPIO_InitStructure;
    607             
    608            /* init for button PD11(s1 user) *///@@ D11->C4
    609            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
   \   00000002   0x2010             MOVS     R0,#+16
   \   00000004   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    610            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   00000008   0x2048             MOVS     R0,#+72
   \   0000000A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    611            GPIO_Init(GPIOC, &GPIO_InitStructure); 
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x....             LDR.N    R0,??DataTable10_22  ;; 0x40011000
   \   00000012   0x.... 0x....      BL       GPIO_Init
    612            
    613            /* Configure the PB7 or BUZZER pin */
    614            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   00000016   0xF44F 0x7000      MOV      R0,#+512
   \   0000001A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    615            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000001E   0x2010             MOVS     R0,#+16
   \   00000020   0xF88D 0x0003      STRB     R0,[SP, #+3]
    616            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xF88D 0x0002      STRB     R0,[SP, #+2]
    617            GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x....             LDR.N    R0,??DataTable10_22  ;; 0x40011000
   \   0000002E   0x.... 0x....      BL       GPIO_Init
    618          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    619          

   \                                 In section .text, align 2, keep-with-next
    620          void DS3231_Alarm_Init() {
   \                     DS3231_Alarm_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    621            SystemInit();
   \   00000002   0x.... 0x....      BL       SystemInit
    622            RCC_Configure_ds3231();
   \   00000006   0x.... 0x....      BL       RCC_Configure_ds3231
    623            GPIO_Configure_ds3231();
   \   0000000A   0x.... 0x....      BL       GPIO_Configure_ds3231
    624          
    625            I2C_Configure();
   \   0000000E   0x.... 0x....      BL       I2C_Configure
    626            LCD_Init();
   \   00000012   0x.... 0x....      BL       LCD_Init
    627            LCD_Clear(WHITE);
   \   00000016   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000001A   0x.... 0x....      BL       LCD_Clear
    628          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    629          
    630          
    631          

   \                                 In section .text, align 2, keep-with-next
    632          int alarm_check(ds3231_time *current_time, ds3231_Alarm1 *alarm1_data) {
    633            
    634            
    635            if (current_time->date >= alarm1_data->day_date_select.value) {
   \                     alarm_check: (+1)
   \   00000000   0x7942             LDRB     R2,[R0, #+5]
   \   00000002   0x794B             LDRB     R3,[R1, #+5]
   \   00000004   0x429A             CMP      R2,R3
   \   00000006   0xD31D             BCC.N    ??alarm_check_0
    636              if (current_time->hour_select.am_pm_24 == alarm1_data->hour_select.am_pm_24) {
   \   00000008   0x7882             LDRB     R2,[R0, #+2]
   \   0000000A   0x788B             LDRB     R3,[R1, #+2]
   \   0000000C   0x429A             CMP      R2,R3
   \   0000000E   0xD119             BNE.N    ??alarm_check_0
    637                if (current_time->hour_select.hour >= alarm1_data->hour_select.hour) {
   \   00000010   0x78C2             LDRB     R2,[R0, #+3]
   \   00000012   0x78CB             LDRB     R3,[R1, #+3]
   \   00000014   0x429A             CMP      R2,R3
   \   00000016   0xD315             BCC.N    ??alarm_check_0
    638                  if (current_time->min >= alarm1_data->min) {
   \   00000018   0x7842             LDRB     R2,[R0, #+1]
   \   0000001A   0x784B             LDRB     R3,[R1, #+1]
   \   0000001C   0x429A             CMP      R2,R3
   \   0000001E   0xD311             BCC.N    ??alarm_check_0
    639                    if (current_time->sec >= alarm1_data->sec) {
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD30D             BCC.N    ??alarm_check_0
    640                      if (Alarm_flag == 0) { // @@ @@@
   \   00000028   0x....             LDR.N    R0,??DataTable10_21
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD106             BNE.N    ??alarm_check_1
    641                        Alarm_flag = 1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x....             LDR.N    R1,??DataTable10_21
   \   00000034   0x6008             STR      R0,[R1, #+0]
    642                        Alarm_ONOFF = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x....             LDR.N    R1,??DataTable10_23
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   \   0000003C   0xE002             B.N      ??alarm_check_0
    643                      }
    644                      else {
    645                        Alarm_ONOFF = 0;
   \                     ??alarm_check_1: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x....             LDR.N    R1,??DataTable10_23
   \   00000042   0x6008             STR      R0,[R1, #+0]
    646                      }
    647                    }
    648                  }
    649                }
    650              }
    651            }
    652            return Alarm_ONOFF;
   \                     ??alarm_check_0: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable10_23
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x4770             BX       LR               ;; return
    653          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x2D 0x00          DC8      "-",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x3A 0x00          DC8      ":",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x40010004         DC32     0x40010004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40010C04         DC32     0x40010c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x40005404         DC32     0x40005404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x4000541C         DC32     0x4000541c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x40005420         DC32     0x40005420

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x00070082         DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x10020400         DC32     0x10020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x00030001         DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x00070084         DC32     0x70084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x10000002         DC32     0x10000002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x00030002         DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_21:
   \   00000000   0x........         DC32     Alarm_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_22:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_23:
   \   00000000   0x........         DC32     Alarm_ONOFF

   \                                 In section .rodata, align 1
   \   00000000   0x00               DC8 ""
   \   00000001   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 1
   \   00000000   0x00               DC8 ""
   \   00000001   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x25 0x64          DC8 "%d-%d-%d"
   \              0x2D 0x25    
   \              0x64 0x2D    
   \              0x25 0x64    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x64          DC8 "%d"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2
   \   00000000   0x2D 0x00          DC8 "-"

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x41 0x4D          DC8 "AM : %d:"
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x64 0x3A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x41 0x4D          DC8 "AM : "
   \              0x20 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x3A 0x00          DC8 ":"

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x50 0x4D          DC8 "PM : %d:"
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x64 0x3A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x50 0x4D          DC8 "PM : "
   \              0x20 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x32 0x34          DC8 "24 : %d:"
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x64 0x3A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x32 0x34          DC8 "24 : "
   \              0x20 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x25 0x64          DC8 "%d:%d\015\012"
   \              0x3A 0x25    
   \              0x64 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x53 0x74          DC8 "String : %s\012"
   \              0x72 0x69    
   \              0x6E 0x67    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    654          
    655          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DS3231_Alarm_Init
         8   -> GPIO_Configure_ds3231
         8   -> I2C_Configure
         8   -> LCD_Clear
         8   -> LCD_Init
         8   -> RCC_Configure_ds3231
         8   -> SystemInit
       0   Delay_little
       8   GPIO_Configure_ds3231
         8   -> GPIO_Init
      24   HW_I2C_Read
        24   -> I2C_AcknowledgeConfig
        24   -> I2C_CheckEvent
        24   -> I2C_ClearFlag
        24   -> I2C_Cmd
        24   -> I2C_GenerateSTART
        24   -> I2C_GenerateSTOP
        24   -> I2C_GetFlagStatus
        24   -> I2C_GetLastEvent
        24   -> I2C_ReceiveData
        24   -> I2C_Send7bitAddress
        24   -> I2C_SendData
      24   HW_I2C_Write
        24   -> I2C_CheckEvent
        24   -> I2C_ClearFlag
        24   -> I2C_GenerateSTART
        24   -> I2C_GenerateSTOP
        24   -> I2C_GetLastEvent
        24   -> I2C_Send7bitAddress
        24   -> I2C_SendData
       8   I2C_Configure
         8   -> I2C_Cmd
         8   -> I2C_DeInit
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
       8   RCC_Configure_ds3231
         8   -> RCC_APB2PeriphClockCmd
       0   alarm_check
       0   bcdTodec
       0   decTobcd
      40   ds3231_print_time
        40   -> LCD_ShowString
        40   -> __aeabi_memclr
        40   -> printf
        40   -> sprintf
        40   -> strcat
      16   ds3231_read_alarm1
        16   -> HW_I2C_Read
        16   -> bcdTodec
      24   ds3231_read_time
        24   -> HW_I2C_Read
        24   -> bcdTodec
      16   ds3231_set_alarm1
        16   -> HW_I2C_Write
        16   -> decTobcd
      24   ds3231_write_time
        24   -> HW_I2C_Write
        24   -> decTobcd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
      20  ?_0
       5  ?_1
       8  ?_10
      12  ?_11
       8  ?_12
       8  ?_13
      16  ?_14
      12  ?_2
       4  ?_3
       2  ?_4
       2  ?_5
      12  ?_6
       8  ?_7
       2  ?_8
      12  ?_9
       4  Alarm_ONOFF
       4  Alarm_flag
      32  DS3231_Alarm_Init
      12  Delay_little
      52  GPIO_Configure_ds3231
     684  HW_I2C_Read
     310  HW_I2C_Write
     114  I2C_Configure
      36  RCC_Configure_ds3231
      74  alarm_check
      32  bcdTodec
      30  decTobcd
     362  ds3231_print_time
     208  ds3231_read_alarm1
     238  ds3231_read_time
     194  ds3231_set_alarm1
     242  ds3231_write_time

 
     4 bytes in section .bss
     4 bytes in section .data
   131 bytes in section .rodata
 2 732 bytes in section .text
 
 2 732 bytes of CODE  memory
   131 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: 2
