###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       22/Dec/2023  08:21:10
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\user\Documents\Term_project\user\main.c
#    Command line =  
#        -f C:\Users\user\AppData\Local\Temp\EW29AB.tmp
#        (C:\Users\user\Documents\Term_project\user\main.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\user\Documents\Term_project\Debug\List -o
#        C:\Users\user\Documents\Term_project\Debug\Obj --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\user\Documents\Term_project\Libraries\CMSIS\DeviceSupport\ -I
#        C:\Users\user\Documents\Term_project\Libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\user\Documents\Term_project\Libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\user\Documents\Term_project\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\user\Documents\Term_project\user\inc\ -I
#        C:\Users\user\Documents\Term_project\user\ -I
#        C:\Users\user\Documents\Term_project\Libraries\LCD\ -Ol -I "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  C:\Users\user\Documents\Term_project\Debug\List\main.lst
#    Object file  =  C:\Users\user\Documents\Term_project\Debug\Obj\main.o
#
###############################################################################

C:\Users\user\Documents\Term_project\user\main.c
      1          #include "stm32f10x.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD408             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000E   0x408A             LSLS     R2,R2,R1
   \   00000010   0x....             LDR.N    R1,??DataTable10_1  ;; 0xe000e100
   \   00000012   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000014   0x0940             LSRS     R0,R0,#+5
   \   00000016   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
      2          #include "core_cm3.h"
      3          #include "misc.h"
      4          #include "stm32f10x_gpio.h"
      5          #include "stm32f10x_rcc.h"
      6          #include "stm32f10x_usart.h"
      7          #include "stm32f10x_adc.h"
      8          #include "stm32f10x_tim.h"
      9          
     10          #include "lcd.h"
     11          #include "touch.h"
     12          #include "pir.h"
     13          #include "ultrasonic.h"
     14          
     15          #include <bluetooth.h>
     16          #include <stdio.h>
     17          #include <stdlib.h>
     18          #include <moveWheel.h>
     19          #include <DS3231_BUZZER.h>
     20          #include <stop_button.h>
     21          #include "stm32f10x_exti.h"
     22          
     23          
     24          void RCC_Configure(void);
     25          void GPIO_Configure(void);
     26          
     27          void is_answer(void);
     28          
     29          void setDirection();
     30          

   \                                 In section .bss, align 4
     31          int directionFlag = 0;
   \                     directionFlag:
   \   00000000                      DS8 4

   \                                 In section .data, align 4
     32          int onOff = 1;
   \                     onOff:
   \   00000000   0x00000001         DC32 1
     33          extern int Alarm_ONOFF;//have to combine isAlramOn

   \                                 In section .bss, align 4
     34          int answer;
   \                     answer:
   \   00000000                      DS8 4
     35          
     36          
     37          
     38          
     39          //---------------------------------------------------------------------------------------------------
     40          
     41          

   \                                 In section .text, align 2, keep-with-next
     42          void RCC_Configure(void)
     43          {
   \                     RCC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     44            RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);    // interrupt
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     45            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE);  // RCC GPIO D
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2020             MOVS     R0,#+32
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     46          
     47          
     48            TIM_ClearITPendingBit(TIM2, TIM_IT_CC2);
   \   00000012   0x2104             MOVS     R1,#+4
   \   00000014   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000018   0x.... 0x....      BL       TIM_ClearITPendingBit
     49          // Clear TIM2 Capture compare interrupt pending bit
     50          
     51          }
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
     52          
     53          //------------------------------------------------- blue tooth below------------
     54          

   \                                 In section .bss, align 4
     55          uint16_t receive_string[50];
   \                     receive_string:
   \   00000000                      DS8 100
     56          extern uint16_t user_answer[10];

   \                                 In section .bss, align 4
     57          int string_count = 0;
   \                     string_count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     58          int day = 0;
   \                     day:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     59          int hour = 0;
   \                     hour:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     60          int minute = 0;
   \                     minute:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     61          int string_receive_offset = 0;
   \                     string_receive_offset:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     62          int start_offset = 0;
   \                     start_offset:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     63          int answer_correct;
   \                     answer_correct:
   \   00000000                      DS8 4
     64          //---------------------------------------------------------------------------------------------------
     65          

   \                                 In section .text, align 2, keep-with-next
     66          void RCC_Configure_bluetooth(void)
     67          {
   \                     RCC_Configure_bluetooth: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     68             // TODO: Enable the APB2 peripheral clock using the function 'RCC_APB2PeriphClockCmd'
     69             /* UART TX/RX port clock enable */
     70             
     71             RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); //UART 4
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2010             MOVS     R0,#+16
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     72          
     73             /* USART4 clock enable */ 
     74             RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xF45F 0x2000      MOVS     R0,#+524288
   \   00000010   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     75                
     76             /* Alternate Function IO clock enable */
     77             RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     78          }
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
     79          

   \                                 In section .text, align 2, keep-with-next
     80          void GPIO_Configure_bluetooth(void)
     81          {
   \                     GPIO_Configure_bluetooth: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     82              GPIO_InitTypeDef GPIO_InitStructure;
     83          
     84             // TODO: Initialize the GPIO pins using the structure 'GPIO_InitTypeDef' and the function 'GPIO_Init'
     85              
     86          
     87              
     88              //TX2
     89              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   00000002   0xF44F 0x6080      MOV      R0,#+1024
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     90              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0xF88D 0x0002      STRB     R0,[SP, #+2]
     91              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000010   0x2018             MOVS     R0,#+24
   \   00000012   0xF88D 0x0003      STRB     R0,[SP, #+3]
     92              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40011000
   \   0000001A   0x.... 0x....      BL       GPIO_Init
     93              
     94              //RX2
     95              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
   \   0000001E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000022   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     96              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   00000026   0x2048             MOVS     R0,#+72
   \   00000028   0xF88D 0x0003      STRB     R0,[SP, #+3]
     97              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40011000
   \   00000030   0x.... 0x....      BL       GPIO_Init
     98          }
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
     99          

   \                                 In section .text, align 2, keep-with-next
    100          void USART4_Init(void)
    101          {
   \                     USART4_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    102             USART_InitTypeDef USART_InitStructure;
    103          
    104             USART_Cmd(UART4, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40004c00
   \   00000006   0x.... 0x....      BL       USART_Cmd
    105             
    106          
    107             USART_InitStructure.USART_BaudRate = 9600;
   \   0000000A   0xF44F 0x5016      MOV      R0,#+9600
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    108             USART_InitStructure.USART_StopBits = USART_StopBits_1_5;
   \   00000010   0xF44F 0x5040      MOV      R0,#+12288
   \   00000014   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    109             USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    110             USART_InitStructure.USART_Parity = USART_Parity_No;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    111             USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    112             USART_InitStructure.USART_Mode= USART_Mode_Rx| USART_Mode_Tx;
   \   0000002A   0x200C             MOVS     R0,#+12
   \   0000002C   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    113             USART_Init(UART4, &USART_InitStructure);
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40004c00
   \   00000034   0x.... 0x....      BL       USART_Init
    114             
    115          
    116             USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0xF240 0x5125      MOVW     R1,#+1317
   \   0000003E   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40004c00
   \   00000040   0x.... 0x....      BL       USART_ITConfig
    117          }
   \   00000044   0xB005             ADD      SP,SP,#+20
   \   00000046   0xBD00             POP      {PC}             ;; return
    118          

   \                                 In section .text, align 2, keep-with-next
    119          void NVIC_Configure_bluetooth(void) {
   \                     NVIC_Configure_bluetooth: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    120          
    121              NVIC_InitTypeDef NVIC_InitStructure;
    122              
    123              // TODO: fill the arg you want
    124              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \   00000002   0xF44F 0x60A0      MOV      R0,#+1280
   \   00000006   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    125             
    126              
    127              NVIC_EnableIRQ(UART4_IRQn);
   \   0000000A   0x2034             MOVS     R0,#+52
   \   0000000C   0x.... 0x....      BL       __NVIC_EnableIRQ
    128              NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
   \   00000010   0x2034             MOVS     R0,#+52
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
    129              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; 
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF88D 0x0001      STRB     R0,[SP, #+1]
    130              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    131              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0003      STRB     R0,[SP, #+3]
    132              NVIC_Init(&NVIC_InitStructure);
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x.... 0x....      BL       NVIC_Init
    133          }
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    134          

   \                                 In section .text, align 2, keep-with-next
    135          void UART4_IRQHandler() {
   \                     UART4_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    136             uint16_t word;
    137              if(USART_GetITStatus(UART4,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40004c00
   \   00000008   0x.... 0x....      BL       USART_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD04A             BEQ.N    ??UART4_IRQHandler_0
    138                 // the most recent received data by the USART1 peripheral
    139                 word = USART_ReceiveData(UART4);
   \   00000010   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40004c00
   \   00000012   0x.... 0x....      BL       USART_ReceiveData
   \   00000016   0x0004             MOVS     R4,R0
    140                 
    141                 if (start_offset == 1) {     
   \   00000018   0x....             LDR.N    R0,??DataTable10_4
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD118             BNE.N    ??UART4_IRQHandler_1
    142                   //0x3b@ ;@ @@@ -> ;@ @@@ @@ @@ @@ @@@@ @@ @@(string_partition) @@
    143                   if (word == 0x3b) { //SetAlarm 7-19:20 [0x53, 0x65, 0x74, 0x41, 0x6c, 0x61, 0x72, 0x6d, 0x20, 0x37, 0x2d, 0x31, 0x39, 0x3a, 0x32, 0x30]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x283B             CMP      R0,#+59
   \   00000026   0xD105             BNE.N    ??UART4_IRQHandler_2
    144                     
    145                     string_partition();
   \   00000028   0x.... 0x....      BL       string_partition
    146                     start_offset = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable10_4
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE00E             B.N      ??UART4_IRQHandler_1
    147                   }
    148                   else {
    149                     receive_string[string_count] = word; 
   \                     ??UART4_IRQHandler_2: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable10_5
   \   00000036   0x....             LDR.N    R1,??DataTable10_6
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0xF820 0x4011      STRH     R4,[R0, R1, LSL #+1]
    150                     string_count++;
   \   0000003E   0x....             LDR.N    R0,??DataTable10_6
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable10_6
   \   00000046   0x6008             STR      R0,[R1, #+0]
    151          
    152                     // clear 'Read data register not empty' flag
    153                     USART_ClearITPendingBit(UART4,USART_IT_RXNE);
   \   00000048   0xF240 0x5125      MOVW     R1,#+1317
   \   0000004C   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40004c00
   \   0000004E   0x.... 0x....      BL       USART_ClearITPendingBit
    154                   }
    155                 }
    156                 
    157                 //0x40@ @@ @@@ -> @@ @@@ @@ @@ @@
    158                 if (word == 0x40)  start_offset = 1;
   \                     ??UART4_IRQHandler_1: (+1)
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000056   0x2840             CMP      R0,#+64
   \   00000058   0xD102             BNE.N    ??UART4_IRQHandler_3
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x....             LDR.N    R1,??DataTable10_4
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    159                 
    160                 
    161                 
    162                 
    163                 if (start_offset ==2){
   \                     ??UART4_IRQHandler_3: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable10_4
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x2802             CMP      R0,#+2
   \   00000066   0xD118             BNE.N    ??UART4_IRQHandler_4
    164                   // ; @@@ @@ @@
    165                   if (word == 0x3b){//;
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006C   0x283B             CMP      R0,#+59
   \   0000006E   0xD105             BNE.N    ??UART4_IRQHandler_5
    166                     is_answer();
   \   00000070   0x.... 0x....      BL       is_answer
    167                     start_offset = 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x....             LDR.N    R1,??DataTable10_4
   \   00000078   0x6008             STR      R0,[R1, #+0]
   \   0000007A   0xE00E             B.N      ??UART4_IRQHandler_4
    168                   }
    169                   else {
    170                     receive_string[string_count] = word;
   \                     ??UART4_IRQHandler_5: (+1)
   \   0000007C   0x....             LDR.N    R0,??DataTable10_5
   \   0000007E   0x....             LDR.N    R1,??DataTable10_6
   \   00000080   0x6809             LDR      R1,[R1, #+0]
   \   00000082   0xF820 0x4011      STRH     R4,[R0, R1, LSL #+1]
    171                     string_count++;
   \   00000086   0x....             LDR.N    R0,??DataTable10_6
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0x....             LDR.N    R1,??DataTable10_6
   \   0000008E   0x6008             STR      R0,[R1, #+0]
    172                     
    173                     USART_ClearITPendingBit(UART4,USART_IT_RXNE);
   \   00000090   0xF240 0x5125      MOVW     R1,#+1317
   \   00000094   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40004c00
   \   00000096   0x.... 0x....      BL       USART_ClearITPendingBit
    174                   }
    175                 }
    176          
    177                 //=@ @@@@ @@@ @@ @@
    178                 if (word == 0x3d) start_offset = 2;
   \                     ??UART4_IRQHandler_4: (+1)
   \   0000009A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000009C   0x2C3D             CMP      R4,#+61
   \   0000009E   0xD102             BNE.N    ??UART4_IRQHandler_0
   \   000000A0   0x2002             MOVS     R0,#+2
   \   000000A2   0x....             LDR.N    R1,??DataTable10_4
   \   000000A4   0x6008             STR      R0,[R1, #+0]
    179              
    180              }
    181          }
   \                     ??UART4_IRQHandler_0: (+1)
   \   000000A6   0xBD10             POP      {R4,PC}          ;; return
    182          

   \                                 In section .text, align 2, keep-with-next
    183          void sendDataToUART4(uint16_t data) {
   \                     sendDataToUART4: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    184            while ((UART4->SR & USART_SR_TXE) == 0);
   \                     ??sendDataToUART4_0: (+1)
   \   00000004   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40004c00
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0x0600             LSLS     R0,R0,#+24
   \   0000000A   0xD5FB             BPL.N    ??sendDataToUART4_0
    185              USART_SendData(UART4, data);
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40004c00
   \   00000010   0x.... 0x....      BL       USART_SendData
    186          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    187          
    188          

   \                                 In section .text, align 2, keep-with-next
    189          void is_answer(void) { //@@@
   \                     is_answer: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    190            
    191            char String[10];
    192            int st = 10-string_count;
   \   00000002   0x....             LDR.N    R0,??DataTable10_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF1D0 0x000A      RSBS     R0,R0,#+10
    193            
    194            for (int i = 0; i < 10; i++) {
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xE003             B.N      ??is_answer_0
    195              String[i] = 0x30;
   \                     ??is_answer_1: (+1)
   \   0000000E   0x2230             MOVS     R2,#+48
   \   00000010   0x466B             MOV      R3,SP
   \   00000012   0x545A             STRB     R2,[R3, R1]
    196            }
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \                     ??is_answer_0: (+1)
   \   00000016   0x290A             CMP      R1,#+10
   \   00000018   0xDBF9             BLT.N    ??is_answer_1
    197            
    198            for (int i = 0; i < string_count; i++) {
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xE00A             B.N      ??is_answer_2
    199              String[st+i] = (char)receive_string[i];
   \                     ??is_answer_3: (+1)
   \   0000001E   0x....             LDR.N    R2,??DataTable10_5
   \   00000020   0xF832 0x2011      LDRH     R2,[R2, R1, LSL #+1]
   \   00000024   0x466B             MOV      R3,SP
   \   00000026   0x180C             ADDS     R4,R1,R0
   \   00000028   0x551A             STRB     R2,[R3, R4]
    200              receive_string[i] = 0;
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x....             LDR.N    R3,??DataTable10_5
   \   0000002E   0xF823 0x2011      STRH     R2,[R3, R1, LSL #+1]
    201            } //@@@ @@@@ String @@@ @@@ @@ @@@ @ @@@ @@@@
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   \                     ??is_answer_2: (+1)
   \   00000034   0x....             LDR.N    R2,??DataTable10_6
   \   00000036   0x6812             LDR      R2,[R2, #+0]
   \   00000038   0x4291             CMP      R1,R2
   \   0000003A   0xDBF0             BLT.N    ??is_answer_3
    202            
    203             st = atoi(String);
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x.... 0x....      BL       atoi
    204          
    205            
    206            if (st == answer){
   \   00000042   0x....             LDR.N    R1,??DataTable10_7
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD109             BNE.N    ??is_answer_4
    207              string_count = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x....             LDR.N    R1,??DataTable10_6
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    208              sendDataToUART4('O');
   \   00000050   0x204F             MOVS     R0,#+79
   \   00000052   0x.... 0x....      BL       sendDataToUART4
    209              answer_correct = 1;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x....             LDR.N    R1,??DataTable10_8
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   \   0000005C   0xE002             B.N      ??is_answer_5
    210            }else{
    211              sendDataToUART4('X');
   \                     ??is_answer_4: (+1)
   \   0000005E   0x2058             MOVS     R0,#+88
   \   00000060   0x.... 0x....      BL       sendDataToUART4
    212            }
    213          }
   \                     ??is_answer_5: (+1)
   \   00000064   0xBD1F             POP      {R0-R4,PC}       ;; return
    214          

   \                                 In section .text, align 2, keep-with-next
    215          void string_partition(void) {
   \                     string_partition: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xB0A4             SUB      SP,SP,#+144
    216            char String[50];
    217            
    218            for (int i = 0; i < string_count; i++) {
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xE009             B.N      ??string_partition_0
    219              String[i] = (char)receive_string[i];
   \                     ??string_partition_1: (+1)
   \   00000008   0x....             LDR.N    R1,??DataTable10_5
   \   0000000A   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   0000000E   0xAA17             ADD      R2,SP,#+92
   \   00000010   0x5411             STRB     R1,[R2, R0]
    220              receive_string[i] = 0;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x....             LDR.N    R2,??DataTable10_5
   \   00000016   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
    221            } //@@@ @@@@ String @@@ @@@ receive_string @@@ @ @@@ @@@@
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \                     ??string_partition_0: (+1)
   \   0000001C   0x....             LDR.N    R1,??DataTable10_6
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xDBF1             BLT.N    ??string_partition_1
    222            
    223            string_count = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x....             LDR.N    R1,??DataTable10_6
   \   00000028   0x6008             STR      R0,[R1, #+0]
    224            
    225            char temp[50], *point;
    226            char* parti = " -:";
   \   0000002A   0x....             ADR.N    R4,??DataTable10  ;; " -:"
    227            char* partion_char[10];
    228            int i = 0;
   \   0000002C   0x2500             MOVS     R5,#+0
    229            
    230            strcpy(temp, String);
   \   0000002E   0xA917             ADD      R1,SP,#+92
   \   00000030   0xA80A             ADD      R0,SP,#+40
   \   00000032   0x.... 0x....      BL       strcpy
    231            point = strtok(temp, parti); //parti @@@ @@@ @@@@ string @@ @@@
   \   00000036   0x0021             MOVS     R1,R4
   \   00000038   0x.... 0x....      BL       strtok
   \   0000003C   0xE007             B.N      ??string_partition_2
    232            
    233            while(point) {
    234              partion_char[i] = point;
   \                     ??string_partition_3: (+1)
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
    235              i++;
   \   00000044   0x1C6D             ADDS     R5,R5,#+1
    236              point = strtok(NULL, parti);
   \   00000046   0x0021             MOVS     R1,R4
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      BL       strtok
    237            }
   \                     ??string_partition_2: (+1)
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD1F5             BNE.N    ??string_partition_3
    238            
    239            if (strcmp(partion_char[0], "SetAlarm") == 0) {
   \   00000052   0x....             LDR.N    R1,??DataTable10_9
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x.... 0x....      BL       strcmp
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD120             BNE.N    ??string_partition_4
    240              day = atoi(partion_char[1]);
   \   0000005E   0x9801             LDR      R0,[SP, #+4]
   \   00000060   0x.... 0x....      BL       atoi
   \   00000064   0x....             LDR.N    R1,??DataTable10_10
   \   00000066   0x6008             STR      R0,[R1, #+0]
    241              hour = atoi(partion_char[2]);
   \   00000068   0x9802             LDR      R0,[SP, #+8]
   \   0000006A   0x.... 0x....      BL       atoi
   \   0000006E   0x....             LDR.N    R1,??DataTable10_11
   \   00000070   0x6008             STR      R0,[R1, #+0]
    242              minute = atoi(partion_char[3]);
   \   00000072   0x9803             LDR      R0,[SP, #+12]
   \   00000074   0x.... 0x....      BL       atoi
   \   00000078   0x....             LDR.N    R1,??DataTable10_12
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    243              string_receive_offset = 1;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0x....             LDR.N    R1,??DataTable10_13
   \   00000080   0x6008             STR      R0,[R1, #+0]
    244              
    245              char msg[] = "Alarm setting Complete\n";
   \   00000082   0x4668             MOV      R0,SP
   \   00000084   0x....             LDR.N    R1,??DataTable10_14
   \   00000086   0x2218             MOVS     R2,#+24
   \   00000088   0x.... 0x....      BL       __aeabi_memcpy4
    246                                  
    247              for(int i = 0; i < 23; i++) {
   \   0000008C   0x2400             MOVS     R4,#+0
   \   0000008E   0xE005             B.N      ??string_partition_5
    248                   sendDataToUART4(msg[i]);
   \                     ??string_partition_6: (+1)
   \   00000090   0x4668             MOV      R0,SP
   \   00000092   0x5D00             LDRB     R0,[R0, R4]
   \   00000094   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000096   0x.... 0x....      BL       sendDataToUART4
    249              }
   \   0000009A   0x1C64             ADDS     R4,R4,#+1
   \                     ??string_partition_5: (+1)
   \   0000009C   0x2C17             CMP      R4,#+23
   \   0000009E   0xDBF7             BLT.N    ??string_partition_6
    250            }  
    251          }
   \                     ??string_partition_4: (+1)
   \   000000A0   0xB025             ADD      SP,SP,#+148
   \   000000A2   0xBD30             POP      {R4,R5,PC}       ;; return
    252          
    253          
    254          
    255          

   \                                 In section .text, align 2, keep-with-next
    256          void bluetooth_Init(void) {
   \                     bluetooth_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    257            RCC_Configure_bluetooth();
   \   00000002   0x.... 0x....      BL       RCC_Configure_bluetooth
    258            GPIO_Configure_bluetooth();
   \   00000006   0x.... 0x....      BL       GPIO_Configure_bluetooth
    259            USART4_Init();
   \   0000000A   0x.... 0x....      BL       USART4_Init
    260            NVIC_Configure_bluetooth();
   \   0000000E   0x.... 0x....      BL       NVIC_Configure_bluetooth
    261          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    262          

   \                                 In section .text, align 2, keep-with-next
    263          int get_day(void) {
    264            return day;
   \                     get_day: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    265          }
    266          

   \                                 In section .text, align 2, keep-with-next
    267          int get_hour(void) {
    268            return hour;
   \                     get_hour: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_11
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    269          }
    270          

   \                                 In section .text, align 2, keep-with-next
    271          int get_minute(void) {
    272            string_receive_offset = 0;
   \                     get_minute: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable10_13
   \   00000004   0x6008             STR      R0,[R1, #+0]
    273            
    274            return minute;
   \   00000006   0x....             LDR.N    R0,??DataTable10_12
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x4770             BX       LR               ;; return
    275          }
    276          

   \                                 In section .text, align 2, keep-with-next
    277          int get_receive_flag(void) {
    278            return string_receive_offset;
   \                     get_receive_flag: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_13
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    279          }
    280          
    281          
    282          //@@@ @@@ @@

   \                                 In section .text, align 2, keep-with-next
    283          void setDirection(int flag){
   \                     setDirection: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    284            switch(flag){
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD008             BEQ.N    ??setDirection_0
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD00C             BEQ.N    ??setDirection_1
   \   0000000A   0xD308             BCC.N    ??setDirection_2
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00F             BEQ.N    ??setDirection_3
   \   00000010   0xD30B             BCC.N    ??setDirection_4
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD00F             BEQ.N    ??setDirection_5
   \   00000016   0xE010             B.N      ??setDirection_6
    285            case 0:
    286              setDirectionToFront();
   \                     ??setDirection_0: (+1)
   \   00000018   0x.... 0x....      BL       setDirectionToFront
    287              break;
   \   0000001C   0xE00D             B.N      ??setDirection_6
    288            case 1:
    289              turnToLeft();
   \                     ??setDirection_2: (+1)
   \   0000001E   0x.... 0x....      BL       turnToLeft
    290              break;
   \   00000022   0xE00A             B.N      ??setDirection_6
    291            case 2:
    292              setDirectionToBack();
   \                     ??setDirection_1: (+1)
   \   00000024   0x.... 0x....      BL       setDirectionToBack
    293              break;
   \   00000028   0xE007             B.N      ??setDirection_6
    294            case 3:
    295              turnToRight();
   \                     ??setDirection_4: (+1)
   \   0000002A   0x.... 0x....      BL       turnToRight
    296              break;
   \   0000002E   0xE004             B.N      ??setDirection_6
    297            case 4:
    298              turnToLeft();
   \                     ??setDirection_3: (+1)
   \   00000030   0x.... 0x....      BL       turnToLeft
    299              break;
   \   00000034   0xE001             B.N      ??setDirection_6
    300            case 5:
    301              setDirectionToFront();
   \                     ??setDirection_5: (+1)
   \   00000036   0x.... 0x....      BL       setDirectionToFront
    302              break;
    303            }
    304          }
   \                     ??setDirection_6: (+1)
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
    305          
    306          
    307          

   \                                 In section .text, align 2, keep-with-next
    308          void delay(int n){
    309          
    310            for (int i = 0; i < n;i++);
   \                     delay: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE000             B.N      ??delay_0
   \                     ??delay_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \                     ??delay_0: (+1)
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xDBFC             BLT.N    ??delay_1
    311          };
   \   0000000A   0x4770             BX       LR               ;; return
    312          

   \                                 In section .text, align 2, keep-with-next
    313           int main() {
   \                     main: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    314            
    315            SystemInit();
   \   00000002   0x.... 0x....      BL       SystemInit
    316            bluetooth_Init();
   \   00000006   0x.... 0x....      BL       bluetooth_Init
    317            RCC_Configure();
   \   0000000A   0x.... 0x....      BL       RCC_Configure
    318            
    319            RCC_Configure_wheel_pin();
                   ^
Warning[Pe223]: function "RCC_Configure_wheel_pin" declared implicitly
   \   0000000E   0x.... 0x....      BL       RCC_Configure_wheel_pin
    320            GPIO_Configure_wheel();
   \   00000012   0x.... 0x....      BL       GPIO_Configure_wheel
    321            
    322            DS3231_Alarm_Init();
   \   00000016   0x.... 0x....      BL       DS3231_Alarm_Init
    323            
    324          
    325            LCD_Init();
   \   0000001A   0x.... 0x....      BL       LCD_Init
    326            LCD_Clear(WHITE);
   \   0000001E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000022   0x.... 0x....      BL       LCD_Clear
    327            
    328            while(1){setDirectionToBack();}
   \                     ??main_0: (+1)
   \   00000026   0x.... 0x....      BL       setDirectionToBack
   \   0000002A   0xE7FC             B.N      ??main_0
    329              
    330            ds3231_time ds_time_default;   //@@@ @@ @@
    331            ds3231_Alarm1 alarm1_default;
    332            //DS3231@ @@@ @@@ @@ @@@@@ @@ (@@@ @@@ @@ @@)
    333            ds_time_default.sec=0;
                   ^
Warning[Pe111]: statement is unreachable
    334            ds_time_default.min=5;
    335            ds_time_default.hour_select.am_pm_24=ds3231_24_hour;
    336            ds_time_default.hour_select.hour=10;
    337            ds_time_default.day=6;
    338            ds_time_default.date=22;
    339            ds_time_default.month=12;
    340            ds_time_default.year=23;
    341            
    342            ds3231_write_time(&ds_time_default);   //@@@@ @@@ DS3231@ @@ @@@ @@
    343            ds3231_read_time(&ds_time_default);
    344            //@@@ @@@@@ @@@@ @@ @@ @@@@@ @@@@@@ @@ @@@ @@@
    345          
    346            
    347            alarm1_default.sec=10;
    348            alarm1_default.min = 30;
    349            alarm1_default.hour_select.am_pm_24=ds3231_24_hour;
    350            alarm1_default.hour_select.hour = 10;
    351            alarm1_default.day_date_select.value = 22;
    352            alarm1_default.day_date_select.day_or_date=ds3231_date;
    353            
    354            ds3231_set_alarm1(&alarm1_default);
    355            ds3231_read_alarm1(&alarm1_default);
    356          
    357          
    358              
    359          
    360            int sec1 = ds_time_default.sec;
    361            int min1 = ds_time_default.min;
    362            int hour1 = ds_time_default.hour_select.hour;
    363            int hour_am_pm1 = ds_time_default.hour_select.am_pm_24;
                       ^
Warning[Pe550]: variable "hour_am_pm1" was set but never used
    364            int day1 = ds_time_default.day;
    365            int date1 = ds_time_default.date;
    366            int month1 = ds_time_default.month;
    367            int year1 = ds_time_default.year;
    368            
    369            
    370            int alarm_sec = 0;
    371            int alarm_min = 0;
    372            int alarm_hour = 0;
    373            int alarm_day = 0;
                       ^
Warning[Pe550]: variable "alarm_day" was set but never used
    374            
    375            while(1){
    376          
    377              
    378              //RTC
    379              ds3231_read_time(&ds_time_default);
    380              ds3231_read_alarm1(&alarm1_default);
    381              GPIO_ResetBits(GPIOC, GPIO_Pin_9); //+ @@@ => 0@@ @@@ @@@ @@@ @@ 1@ @@@
    382              
    383              int problem1 = 0;
    384              int problem2 = 0;
    385              
    386              
    387              if(alarm_check(&ds_time_default, &alarm1_default)){
    388          
    389                int sec_problem = alarm1_default.sec;
    390                int min_problem = alarm1_default.min;
    391                int hour_problem = alarm1_default.hour_select.hour;
    392                
    393                
    394                //GPIO_SetBits(GPIOC, GPIO_Pin_9); // @@ @@
    395                GPIO_SetBits(GPIOC, GPIO_Pin_9);
    396                
    397                
    398                LCD_Clear(WHITE);
    399                
    400                
    401                while (1) {
    402                    GPIO_SetBits(GPIOB, GPIO_Pin_12);
    403                    GPIO_ResetBits(GPIOB, GPIO_Pin_13);
    404                    GPIO_SetBits(GPIOA, GPIO_Pin_4);
    405                    GPIO_ResetBits(GPIOA, GPIO_Pin_5);
    406                  
    407                   
    408                   
    409                   //sec%hour, min%hour, X
    410                   problem1 = sec_problem + hour_problem;
    411                   problem2 = min_problem * hour_problem;
    412                   
    413                  answer = problem1 * problem2;
    414                  
    415                  LCD_ShowString(70, 100, "Solve the problem", BLACK, WHITE);
    416                  LCD_ShowNum(90, 150, problem1, 2, BLACK, WHITE);
    417                  LCD_ShowString(110, 150, "X", BLACK, WHITE);
    418                  LCD_ShowNum(130, 150, problem2, 2, BLACK, WHITE);
    419                  LCD_ShowString(150, 150, "=", BLACK, WHITE);
    420                  LCD_ShowString(170, 150, "?", BLACK, WHITE);
    421                  LCD_ShowString(130, 300, "Alarm_on", 0x0000, 0xFFFF);
    422                  
    423          
    424                  
    425                  if (answer_correct) { // S1 @@ @@@
    426                    LCD_Clear(WHITE);
    427                    GPIO_ResetBits(GPIOC, GPIO_Pin_9); // @@ @@
    428                    Delay_little();
    429                    LCD_ShowString(30, 300, "Alarm_off", 0x0000, 0xFFFF);
    430                    LCD_Clear(WHITE);
    431                    answer_correct=0;
    432                    stopAllWheel();
    433                    break;
    434                  }
    435                }
    436              }
    437                
    438              
    439              
    440                
    441                
    442                if (get_receive_flag() == 1) {
    443                  
    444                alarm_day = get_day();
    445                alarm_min = get_minute();
    446                alarm_hour = get_hour();
    447                
    448                alarm1_default.day_date_select.value = get_day();
    449                alarm1_default.hour_select.hour = get_hour();
    450                alarm1_default.min = get_minute();
    451                ds3231_set_alarm1(&alarm1_default);
    452                ds3231_read_alarm1(&alarm1_default);
    453              }
    454              
    455              // @@ @@ @@@@.
    456                sec1 = ds_time_default.sec;
    457                min1 = ds_time_default.min;
    458                hour1 = ds_time_default.hour_select.hour;
    459                hour_am_pm1 = ds_time_default.hour_select.am_pm_24;
    460                day1 = ds_time_default.day;
    461                date1 = ds_time_default.date;
    462                month1 = ds_time_default.month;
    463                year1 = ds_time_default.year;
    464              
    465                
    466                //@@@@@ @@ @@@@ LCD@ @@.
    467                LCD_ShowNum(180, 60, GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_9), 2, RED, WHITE); // C8 bit -> @@@ on@@ 1, off@ 0
    468                
    469                LCD_ShowNum(50, 100, year1, 2, BLACK, WHITE);
    470                LCD_ShowString(70, 100, "/", BLACK, WHITE);
    471                LCD_ShowNum(90, 100, month1, 2, BLACK, WHITE);
    472                LCD_ShowString(110, 100, "/", BLACK, WHITE);
    473                LCD_ShowNum(130, 100, date1, 2, BLACK, WHITE);
    474                LCD_ShowString(150, 100, "/", BLACK, WHITE);
    475                LCD_ShowNum(170, 100, day1, 1, BLACK, WHITE);
    476                
    477                LCD_ShowNum(30, 200, ds_time_default.hour_select.am_pm_24, 1, BLACK, WHITE);
    478                LCD_ShowNum(60, 200, hour1, 2, BLACK, WHITE);
    479                LCD_ShowString(90, 200, ":", BLACK, WHITE);
    480                LCD_ShowNum(120, 200, min1, 2, BLACK, WHITE);
    481                LCD_ShowString(150, 200, ":", BLACK, WHITE);
    482                LCD_ShowNum(180, 200, sec1, 2, BLACK, WHITE);
    483                
    484                LCD_ShowNum(60, 250, alarm_hour, 2, BLACK, WHITE);
    485                LCD_ShowString(90, 250, ":", BLACK, WHITE);
    486                LCD_ShowNum(120, 250, alarm_min, 2, BLACK, WHITE);
    487                LCD_ShowString(150, 250, ":", BLACK, WHITE);
    488                LCD_ShowNum(180, 250, alarm_sec, 2, BLACK, WHITE);
    489                
    490                
    491            }
    492          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x20 0x2D          DC8      " -:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     start_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     receive_string

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     string_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     answer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     answer_correct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     day

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x........         DC32     hour

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x........         DC32     minute

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x........         DC32     string_receive_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .rodata, align 4
   \   00000000   0x20 0x2D          DC8 " -:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x53 0x65          DC8 "SetAlarm"
   \              0x74 0x41    
   \              0x6C 0x61    
   \              0x72 0x6D    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x41 0x6C          DC8 "Alarm setting Complete\012"
   \              0x61 0x72    
   \              0x6D 0x20    
   \              0x73 0x65    
   \              0x74 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x43 0x6F    
   \              0x6D 0x70    
   \              0x6C 0x65    
   \              0x74 0x65    
   \              0x0A 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GPIO_Configure_bluetooth
         8   -> GPIO_Init
       8   NVIC_Configure_bluetooth
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   RCC_Configure
         8   -> RCC_APB2PeriphClockCmd
         8   -> TIM_ClearITPendingBit
       8   RCC_Configure_bluetooth
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
       8   UART4_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
         8   -> is_answer
         8   -> string_partition
      24   USART4_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       0   __NVIC_EnableIRQ
       8   bluetooth_Init
         8   -> GPIO_Configure_bluetooth
         8   -> NVIC_Configure_bluetooth
         8   -> RCC_Configure_bluetooth
         8   -> USART4_Init
       0   delay
       0   get_day
       0   get_hour
       0   get_minute
       0   get_receive_flag
      24   is_answer
        24   -> atoi
        24   -> sendDataToUART4
       8   main
         8   -> DS3231_Alarm_Init
         8   -> GPIO_Configure_wheel
         8   -> LCD_Clear
         8   -> LCD_Init
         8   -> RCC_Configure
         8   -> RCC_Configure_wheel_pin
         8   -> SystemInit
         8   -> bluetooth_Init
         8   -> setDirectionToBack
       8   sendDataToUART4
         8   -> USART_SendData
       8   setDirection
         8   -> setDirectionToBack
         8   -> setDirectionToFront
         8   -> turnToLeft
         8   -> turnToRight
     160   string_partition
       160   -> __aeabi_memcpy4
       160   -> atoi
       160   -> sendDataToUART4
       160   -> strcmp
       160   -> strcpy
       160   -> strtok


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ?_0
      12  ?_1
      24  ?_2
      54  GPIO_Configure_bluetooth
      48  NVIC_Configure_bluetooth
      30  RCC_Configure
      30  RCC_Configure_bluetooth
     168  UART4_IRQHandler
      72  USART4_Init
      28  __NVIC_EnableIRQ
       4  answer
       4  answer_correct
      20  bluetooth_Init
       4  day
      12  delay
       4  directionFlag
       6  get_day
       6  get_hour
      12  get_minute
       6  get_receive_flag
       4  hour
     102  is_answer
      44  main
       4  minute
       4  onOff
     100  receive_string
      22  sendDataToUART4
      60  setDirection
       4  start_offset
       4  string_count
     164  string_partition
       4  string_receive_offset

 
 136 bytes in section .bss
   4 bytes in section .data
  40 bytes in section .rodata
 944 bytes in section .text
 
 944 bytes of CODE  memory
  40 bytes of CONST memory
 140 bytes of DATA  memory

Errors: none
Warnings: 4
